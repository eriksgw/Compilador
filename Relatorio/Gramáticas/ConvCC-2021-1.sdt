scope_stack = []
num_expressions = []

search_var(ident, lineno, lazy)
num_expressions_as_json()
new_scope(loop)
check_type(left, right, operation, lineno)

new_loop_label : & { NEXT_LOOP_LABEL = generate_label() }

new_scope : & { add_scope(False) }

new_scope_loop : & { add_scope(True) }

program : new_scope statement {
    global_scope = scope_stack.pop()

    program.scopes = global_scope.as_json(),
    program.num_expressions = num_expressions_as_json(),
    program.code = statement['code']
}

program : new_scope funclist {
    global_scope = scope_stack.pop()

    program.scopes = global_scope.as_json(),
    program.num_expressions = num_expressions_as_json(),
    program.code = statement['code']
}

program : &

funclist : funcdef funclist1 { funclist.code = [*funcdef['code'], *funclist1['code']] }

funclist1 : funclist { funclist1.code = funclist['code'] }

funclist1 : & { funclist1.code = [] }

funcdef : DEF IDENT new_scope LPAREN paramlist RPAREN LBRACE statelist RBRACE {
    scope_stack.pop()

    scope = scope_stack[-1]
    entry = EntradaTabela(IDENT, 'function', paramlist['dim'], [], IDENT.lineno)

    scope.new_entry(entry)

    lazy_check()

    next = generate_label()
    funcdef.code = ['goto {next}', '{IDENT}:', *paramlist['code'], *statelist['code'], '{next}:']
}


types : INT { 
    types.type= INT 
    types.code = INT 
}


types : FLOAT {
    types.type = FLOAT 
    types.code = FLOAT
}


types : STRING {
    types.type = STRING
    types.code = STRING
}


paramlist : STRING listdcl IDENT paramlist1 {
    scope = scope_stack[-1]
    entry = EntradaTabela(IDENT, STRING, listdcl['dim'], [-1] * listdcl['dim'], IDENT.lineno)
    scope.new_entry(entry)

    paramlist.dim = paramlist1['dim'] + 1
    paramlist.code = ['from_params {IDENT}', *paramlist1['code']]
}


paramlist : FLOAT listdcl IDENT paramlist1  {
    scope = scope_stack[-1]
    entry = EntradaTabela(IDENT, FLOAT, listdcl['dim'], [-1] * listdcl['dim'], IDENT.lineno)
    scope.new_entry(entry)

    paralist.dim = paramlist1['dim'] + 1
    paramlist.code = ['from_params {IDENT}', *paramlist1['code']]
    
}

paramlist : INT listdcl IDENT paramlist1 {
    scope = scope_stack[-1]
    entry = EntradaTabela(IDENT, INT, listdcl['dim'], [-1] * listdcl['dim'], IDENT.lineno)
    scope.new_entry(entry)

    paralist.dim = paramlist1['dim'] + 1
    paramlist.code = ['from_params {IDENT}', *paramlist1['code']]
}
 
paramlist: & { 
    paramlist.dim = 0
    paramlist.code = [] 
}

paramlist1 : COMMA paramlist {
    paramlist1.dim = paramlist['dim']
    paramlist1.code = paramlist['code']
}

paramlist1 : & {
    paramlist1.dim = 0
    paramlist1.code = []
}

listdcl-1 : LBRACKET RBRACKET listdcl-2 {
    listdcl-1.dim = listdcl['dim'] + 1
    listdcl-1.code = "[]{listdcl['code']}"
}

listdcl : & {
    listdcl.dim = 0
    listdcl.code = ''
}

statement : INT IDENT statement2 {
    entry = EntradaTabela(IDENT, INT, statement2['dim'], statement2['sizes'], IDENT.lineno)
    scope = scope_stack[-1]
    scope.new_entry(entry)

    statement.code = [*statement2['code'], "int {IDENT}{statement2['aux_code']}"]
}

statement : FLOAT IDENT statement2 {
    entry = EntradaTabela(IDENT, FLOAT, statement2['dim'], statement2['sizes'], IDENT.lineno)
    scope = scope_stack[-1]
    scope.new_entry(entry)

    statement.code = [*statement2['code'], "int {IDENT}{statement2['aux_code']}"]
}

statement : STRING IDENT statement2 {
    entry = EntradaTabela(IDENT, STRING, statement2['dim'], statement2['sizes'], IDENT.lineno)
    scope = scope_stack[-1]
    scope.new_entry(entry)

    statement.code = [*statement2['code'], "int {IDENT}{statement2['aux_code']}"]
}

statement : IDENT statement1 {
    var = search_var(IDENT, IDENT.lineno, statement1['type'] == 'function')
    if statement1['type'] == 'function':
        statement.code = [*statement1['code'], "call {IDENT}{statement1['aux_code']}"]
    else:
        statement.code = [*statement1['code'], "{IDENT}{statement1['aux_code']}"]
}

statement : printstat { statement.code = printstat['code'] } SEMICOLON

statement : readstat { statement.code = readstat['code'] } SEMICOLON

statement : returnstat { statement.code = returnstat['code'] } SEMICOLON

statement : ifstat { statement.code = ifstat['code'] }

statement : forstat { statement.code = forstat['code'] }

statement : whilestat { statement.code = whilestat['code'] }

statement : new_scope LBRACE statelist {
    scope_stack.pop()

    statement.code = statelist['code']
} RBRACE

statement : BREAK { statement.code = ['goto {NEXT_LOOP_LABEL}'] } SEMICOLON

statement : SEMICOLON { statement.code = [] }

statement1 : LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 { 
    statement1.type = 'attribution'
    statement1.left_var_dim = lvalue1['dim'] + 1
    statement1.right_var = atribstat1
    statement1.code = [*numexpression['code'], *lvalue1['code'], *atribstat1['code']]
    statement1.aux_code = "[{numexpression['label']}]{lvalue1['aux_code']} = {atribstat1['label']}"
} SEMICOLON

statement1 : ASSIGN atribstat1 {
    statement1.type = 'attribution'
    statement1.left_var_dim = 0
    statement1.right_var = atribstat1
    statement1.code = atribstat1['code']
    statement1.aux_code = " = {atribstat1['label']}"
} SEMICOLON

statement1 : LPAREN paramlistcall {
    statement1.type = 'function'
    statement1.params = paramlistcall['params']
    statement1.code = paramlistcall['code']
    statement1.aux_code = ", {len(paramlistcall['params'])}"
} RPAREN SEMICOLON

statement2 : LBRACKET numexpression RBRACKET lvalue1 {
    statement2.dim = lvalue1['dim'] + 1
    statement2.sizes = [str(numexpression['node']), *lvalue1['sizes']]
    statement2.code = [*numexpression['code'], *lvalue1['code']]
    statement2.aux_code = "[{numexpression['label']}]{lvalue1['aux_code']}"
} SEMICOLON

statement2 : SEMICOLON {
    statement2.dim = 0
    statement2.sizes = [] 
    statement2.code = []
    statement2.aux_code = ''
}

atribstat1 : expression {
    atribstat1.atrib_type = 'expr'
    atribstat1.node = expression['node']
    atribstat1.code = expression['code']
    atribstat1.label = expression['label']
}

atribstat1 : allocexpression {
    atribstat1.'atrib_type' : 'alloc'
    atribstat1.alloc = allocexpression
    atribstat1.code = allocexpression['code']
    atribstat1.label = allocexpression['label']
}

atribstat1 : funccall { 
    atribstat1.atrib_type = 'funccall'
    atribstat1.function = funccall
    atribstat1.code = funccall['code']
    atribstat1.label = funccall['label'] 
}

funccall : IDENT LPAREN paramlistcall {
    funccall.code = [*paramlistcall['code'], "{tvar} = call {IDENT}, {len(paramlistcall['params'])}"]
    funccall.label = tvar
} RPAREN

paramlistcall : factor paramlistcall2 {
    paramlistcall.params = [var, *paramlistcall2['params']]
    paramlistcall.code = ["param {factor['label']}{paramlistcall2['aux_code']}", *paramlistcall2['code']]
}

paramlistcall : & { 
    paramlistcall.params = []
    paramlistcall.code = [] 
}



paramlistcall1 : COMMA paramlistcall { 
    paramlistcall1.params = paramlistcall['params']
    paramlistcall1.code = paramlistcall['code'] 
}



paramlistcall1 : & {
    paramlistcall1.params = []
    paramlistcall1.code = []
}

paramlistcall2 : LBRACKET numexpression RBRACKET lvalue1 paramlistcall1 {
    paramlistcall2.array = True
    paramlistcall2.dim = lvalue1['dim'] + 1
    paramlistcall2.sizes = [numexpression['node'], *lvalue1['sizes']]
    paramlistcall2.params = paramlistcall1['params']
    paramlistcall2.code = [*numexpression['code'], *lvalue1['code'], *paramlistcall1['code']]
    paramlistcall2.aux_code = "[{numexpression['label']}]{lvalue1['aux_code']}"
}

paramlistcall2 : paramlistcall1 {
    paramlistcall2.array = False
    paramlistcall2.code = paramlistcall1['code']
    paramlistcall2.params = paramlistcall1['params']
    paramlistcall2.aux_code = ''
}

printstat : PRINT expression { printstat.code = [*expression['code'], "print {expression['label']}"] }

readstat : READ expression { readstat.code = [*expression['code'], "read {expression['label']}"] }

returnstat : RETURN returnstat1 { returnstat.code = [*returnstat1['code'], "return {returnstat1['label']}"] }

returnstat1 : expression { returnstat1 = expression}

returnstat1 : & {
    returnstat1.code = [],
    returnstat1.label = ''
}

ifstat : IF LPAREN expression RPAREN statement ifstat1 {
    end_if_label = generate_label()
    if 'label' in ifstat1:
        next = ifstat1['label']

        ifstat.code = [
                *expression['code'],
                "if False {expression['label']} goto {next}",
                *statement['code'],
                "goto {end_if_label}",
                *ifstat1['code'],
                '{end_if_label}:'
        ]
    else:
        ifstat.code = [
                *expression['code'],
                "if False {expression['label']} goto {end_if_label}",
                *statement['code'],
                '{end_if_label}:'
        ]
}

ifstat1 : ELSE statement {
    label = generate_label()
    ifstat1.code = ['{label}:', *statement['code']]
    ifstat1.label = label
}

ifstat1 : & { ifstat1.code = [] }

forstat : new_loop_label FOR LPAREN forstat1-1 SEMICOLON forstat2 SEMICOLON forstat1-2 RPAREN new_scope_loop LBRACE statelist {
    scope_stack.pop()

    start = generate_label()
    next_label = NEXT_LOOP_LABEL

    forstat.code = [
        *forstat1-1['code'],
        '{start}:',
        *forstat2['code'],
        *(["if False {forstat2['label']} goto {next_label}"] if forstat2['label'] else []),
        *statelist['code'],
        *forstat1-2['code'],
        'goto {start}',
        '{next_label}:',
    ]
} RBRACE

forstat1 : IDENT forstat3 {
    search_var(IDENT, IDENT.lineno)
    forstat1.code = [*forstat3['code'], "{IDENT} {forstat3['aux_code']}"] }
}

forstat1 : & { forstat1.code = [] }

forstat2 : expression {
    forstat2.code = expression['code']
    forstat2.label = expression['label']
}

forstat2 : & {
    forstat2.code = []
    forstat2.label = None
}

forstat3 : LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 {
    forstat3.code = [*numexpression['code'], *lvalue1['code']]
    forstat3.aux_code = "[{numexpression['label']}]{lvalue1['aux_code']} = {atribstat1['label']}" 
}

forstat3 : ASSIGN atribstat1 {
    forstat3.code = atribstat1['code']
    forstat3.aux_code = "= {atribstat1['label']}"
}

whilestat : new_loop_label WHILE LPAREN expression RPAREN new_scope_loop LBRACE statelist {
    scope_stack.pop()

    start = generate_label()
    next = NEXT_LOOP_LABEL

    whilestat.code = [
        '{start}:',
        *expression['code'],
        "if False {expression['label']} goto {next}",
        *statement['code'],
        'goto {start}',
        '{next}:',
    ]
} RBRACE

statelist : statement statelist1 { statelist.code = [*statement['code'], *statelist1['code']] }

statelist1 : statelist { statelist1.code = statelist['code'] }

statelist1 : & { statelist1.code = [] }

allocexpression : NEW types LBRACKET numexpression {
    num_expressions.append((numexpression['node'], numexpression.lineno))
} RBRACKET lvalue1 {
    var = get_var()

    allocexpression.label = var
    allocexpression.type = convert_type(types['type'])
    allocexpression.dim = lvalue1['dim'] + 1
    allocexpression.code = [*numexpression['code'], *lvalue1['code'], "{var} = new {types['code']}[{numexpression['label']}]{lvalue1['aux_code']}"], 
}

expression : numexpression expression1 {
    if expression1['code']:
        rvar = get_var()
        expression.node = Node(expression1['operator'], numexpression['node'], expression1['node'], 'bool')
        expression.label = rvar
        expression.code = [
                *numexpression['code'],
                *expression1['code'],
                "{rvar} = {numexpression['label']}" + (" {expression1['operator']} {expression1['label']}" if len(expression1['code']) > 0 else "")
        ]
    else:
        expression = numexpression

    num_expressions.append((expression['node'], numexpression.lineno))
}

expression1 : compoperator { expression1.operator = compoperator } numexpression {
    expression1.node = numexpression['node']
    expression1.label = numexpression['label']
    expression1.'code = numexpression['code']
}

expression1 : & { expression1.code = '' }

compoperator : GT { compoperator = '>' }

compoperator : LT { compoperator = '<' }

compoperator : GE { compoperator = '>=' }

compoperator : LE { compoperator = '<=' }

compoperator : EQ { compoperator = '==' }

compoperator : NEQ { compoperator = '!=' }

numexpression : term numexpression1 {
    if numexpression1['code']:
        rtype = check_type(term['node'], numexpression1['node'], numexpression1['operator'], term.lineno)

        var = get_var()
        numexpression.node = Node(numexpression1['operator'], term['node'], numexpression1['node'], rtype)
        numexpression.label = var
        numexpression.code = [
            *term['code'], 
            *numexpression1['code'], 
            "{var} = {term['label']} {numexpression1['operator']} {numexpression1['label']}"
        ]
    else:
        numexpression = term
}

numexpression1 : addsub { numexpression1.operator = addsub } term {
    numexpression1.node = term['node']
    numexpression1.code = term['code']
    numexpression1.label = term['label']
}

numexpression1 : & { numexpression1.code = [] }

addsub : PLUS { addsub = '+' }

addsub : MINUS { addsub = '-' }

term : unaryexpr term1 {
    if term1['code']:
        rtype = check_type(unaryexpr['node'], term1['node'], term1['operator'], unaryexpr.lineno)

        var = get_var()

        term.node = Node(term1['operator'], unaryexpr['node'], term1['node'], rtype),
        term.label = var
        term.code = [*unaryexpr['code'], "{var} = {unaryexpr['label']} {term1['operator']} {term1['label']}"],
    else:
        term = unaryexpr
}

term1-1 : multdiv { term1-1.operator = multdiv } unaryexpr term1-2 {
    if term1['code']:
        rtype = check_type(unaryexpr['node'], term1-2['node'], term1-2['operator'], unaryexpr.lineno)

        var = get_var()

        term1-1.node = Node(term1-2['operator'], unaryexpr['node'], term1-2['node'], rtype)
        term1-1.label = var
        term1-1.code = [*unaryexpr['code'], *term1-2['code'], "{var} = {unaryexpr['label']} {term1-2['operator']} {term1-2['label']}"]
    else:
        term1-1.node = unaryexpr['node']
        term1-1.label = unaryexpr['label']
        term1-1.code = unaryexpr['code']
}

term1 : & { term1.code = [] }

multdiv : MULTIPLY { multdiv = '*' }

multdiv : DIVIDE { multdiv = '/' }

multdiv : REM { multdiv = '%' }

unaryexpr : addsub factor {
    if (addsub == '-'):
        factor['node'].value *= -1

    var = get_var()

    unaryexpr.node = factor['node']
    unaryexpr.code = [*factor['code'], *(["{var} = {addsub}{factor['label']}"] if addsub == '-' else [])]
    unaryexpr.label = var
}

unaryexpr : factor { unaryexpr = factor }

factor : int_constant {
    var = get_var()

    factor.node = Node(int_constant, None, None, 'int')
    factor.code = ['{var} = {int_constant}'], 'label = var
}

factor : float_constant {
    var = get_var()

    factor.node = Node(float_constant, None, None, 'float')
    factor.code = ['{var} = {float_constant}']
    factor.label = var
}

factor : string_constant {
    var = get_var()

    factor.node = Node(string_constant, None, None, 'string')
    factor.code = ['{var} = {string_constant}']
    factor.label = var
}

factor : null_constant {
    var =  get_var() 

    factor.node = Node('null', None, None, 'null')
    factor.code = code = ['{var} = null']
    factor.label = var
}

factor : IDENT lvalue1 {
    var = search_var(IDENT, IDENT.lineno)
    nvar = get_var()

    factor.node = Node(IDENT + lvalue1['expression'], None, None, type2str(var.type, var.dimension, lvalue1['dim']))
    factor.code = ["{nvar} = {IDENT}{lvalue1['aux_code']}"]
    factor.label = nvar
    factor.vartype = 'ident'
}

factor : LPAREN numexpression RPAREN {
    factor = numexpression

    num_expressions.append((numexpression['node'], numexpression.lineno))
}

lvalue1 : LBRACKET numexpression RBRACKET lvalue1 {
    lvalue1.dim = lvalue1['dim'] + 1
    lvalue1.sizes = [str(numexpression['node']), *lvalue1['sizes']]
    lvalue1.expression =  '[{str(numexpression)}]{lvalue1}'
    lvalue1.code = [*numexpression['code'], *lvalue1['code']]
    lvalue1.aux_code = "[{numexpression['label']}]{lvalue1['aux_code']}"


    num_expressions.append((numexpression['node'], numexpression.lineno))
}

lvalue1 : & {
    lvalue1.dim =  0
    lvalue1.sizes = []
    lvalue1.expression = ''
    lvalue1.code = []
    lvalue1.aux_code = ''
}
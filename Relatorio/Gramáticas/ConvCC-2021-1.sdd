scope_stack = []
num_expressions = []

search_var(ident, lineno, lazy)
num_expressions_as_json()
new_scope(loop)
check_type(left, right, operation, lineno)
lazy_check()

'''
new_loop_label : &
'''

NEXT_LOOP_LABEL = generate_label()

'''
new_scope : &
'''

add_scope(False)

'''
new_scope_loop : &
'''

add_scope(True)

'''
program : new_scope statement | new_scope funclist
'''

global_scope = scope_stack.pop()
program = {
    'scopes': global_scope.as_json(),
    'num_expressions': num_expressions_as_json(),
    'code': statement['code']
}

'''
program : &
'''

'''
funclist : funcdef funclist1
'''

funclist = {
    'code': [*funcdef['code'], *funclist1['code']]
}

'''
funclist1 : funclist
'''

funclist1 = {'code': funclist['code'] }

'''
funclist1 : &
'''

funclist1 = {'code': []}


'''
funcdef : DEF IDENT new_scope LPAREN paramlist RPAREN LBRACE statelist RBRACE
'''

scope_stack.pop()

scope = scope_stack[-1]
entry = EntradaTabela(IDENT, 'function', paramlist['dim'], [], IDENT.lineno)

scope.new_entry(entry)

lazy_check()

next = generate_label()
funcdef = { 'code': ['goto {next}', '{IDENT}:', *paramlist['code'], *statelist['code'], '{next}:'] }

'''
types : INT
'''

types = {'type': INT, 'code': INT}

'''
types : FLOAT
'''

types = {'type': FLOAT, 'code': FLOAT}

'''
types : STRING
'''

types = {'type': STRING, 'code': STRING}

'''
paramlist : STRING listdcl IDENT paramlist1 
'''

scope = scope_stack[-1]
entry = EntradaTabela(IDENT, STRING, listdcl['dim'], [-1] * listdcl['dim'], IDENT.lineno)
scope.new_entry(entry)

paramlist = { 'dim': paramlist1['dim'] + 1, 'code': ['from_params {IDENT}', *paramlist1['code']] }

'''
paramlist : FLOAT listdcl IDENT paramlist1 
'''

scope = scope_stack[-1]
entry = EntradaTabela(IDENT, FLOAT, listdcl['dim'], [-1] * listdcl['dim'], IDENT.lineno)
scope.new_entry(entry)

paramlist = { 'dim': paramlist1['dim'] + 1, 'code': ['from_params {IDENT}', *paramlist1['code']] }

'''
paramlist : INT listdcl IDENT paramlist1 
'''
scope = scope_stack[-1]
entry = EntradaTabela(IDENT, INT, listdcl['dim'], [-1] * listdcl['dim'], IDENT.lineno)
scope.new_entry(entry)

paramlist = { 'dim': paramlist1['dim'] + 1, 'code': [f'from_params {IDENT}', *paramlist1['code']] }

'''
paramlist : &
'''

paramlist = { 'dim': 0, 'code': [] }


'''
paramlist1 : COMMA paramlist
'''

paramlist1 = { 'dim': paramlist['dim'], 'code': paramlist['code'] }


'''
paramlist1 : &
'''
paramlist1 = { 'dim': 0, 'code': [] }


'''
listdcl-1 : LBRACKET RBRACKET listdcl-2
'''

listdcl-1 = {'dim': listdcl-2['dim'] + 1, 'code': "[]{listdcl-2['code']}"}


'''
listdcl : &
'''

listdcl = {'dim': 0, 'code': ''}

'''
statement : INT IDENT statement2
'''

entry = EntradaTabela(IDENT, INT, statement2['dim'], statement2['sizes'], IDENT.lineno)
scope = scope_stack[-1]
scope.new_entry(entry)

statement = {'code': [*statement2['code'], "int {IDENT}{statement2['aux_code']}"]}


'''
statement : FLOAT IDENT statement2
'''

entry = EntradaTabela(IDENT, FLOAT, statement2['dim'], statement2['sizes'], IDENT.lineno)
scope = scope_stack[-1]
scope.new_entry(entry)

statement = {'code': [*statement2['code'], "float {IDENT}{statement2['aux_code']}"]}

'''
statement : STRING IDENT statement2
'''

entry = EntradaTabela(IDENT, STRING, statement2['dim'], statement2['sizes'], IDENT.lineno)
scope = scope_stack[-1]
scope.new_entry(entry)

statement = {'code': [*statement2['code'], "string {IDENT}{statement2['aux_code']}"]}

'''
statement : IDENT statement1
'''

var = search_var(IDENT, IDENT.lineno, statement1['type'] == 'function')
if statement1['type'] == 'function':
    statement = { 'code': [*statement1['code'], "call {IDENT}{statement1['aux_code']}"]}
else:
    statement = { 'code': [*statement1['code'], "{IDENT}{statement1['aux_code']}"]}

'''
statement : printstat SEMICOLON
'''

statement = { 'code' : printstat['code'] }
 

'''
statement : readstat SEMICOLON
'''

statement = { 'code' : readstat['code'] }


'''
statement : returnstat SEMICOLON
'''
statement = { 'code' : returnstat['code'] }


'''
statement : ifstat
'''
statement = { 'code' : ifstat['code'] }

'''
statement : forstat
'''
statement = { 'code' : forstat['code'] }

'''
statement : whilestat
'''
statement = { 'code' : whilestat['code'] }

'''
statement : new_scope LBRACE statelist RBRACE
'''
scope_stack.pop()

statement = { 'code' : statelist['code'] }

'''
statement : BREAK SEMICOLON
'''

statement = { 'code': [f'goto {NEXT_LOOP_LABEL}'] }

'''
statement : SEMICOLON
'''
statement = { 'code': [] }

'''
statement1 : LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON
'''

statement1 = {
    'type': 'attribution',
    'left_var_dim': lvalue1['dim'] + 1,
    'right_var': atribstat1,
    'code': [*numexpression['code'], *lvalue1['code'], *atribstat1['code']],
    'aux_code': "[{numexpression['label']}]{lvalue1['aux_code']} = {atribstat1['label']}"
}


'''
statement1 : ASSIGN atribstat1 SEMICOLON
'''

statement1 = {
    'type': 'attribution',
    'left_var_dim': 0,
    'right_var': atribstat1,
    'code': atribstat1['code'],
    'aux_code': " = {atribstat1['label']}"
}


'''
statement1 : LPAREN paramlistcall RPAREN SEMICOLON
'''

statement1 = { 'type': 'function', 'params': paramlistcall['params'], 'code': paramlistcall['code'], 'aux_code': ", {len(paramlistcall['params'])}" }


'''
statement2 : LBRACKET numexpression RBRACKET lvalue1 SEMICOLON
'''

statement2 = { 
    'dim': lvalue1['dim'] + 1,
    'sizes': [numexpression['node'], *lvalue1['sizes']],
    'code': [*numexpression['code'], *lvalue1['code']],
    'aux_code': "[{numexpression['label']}]{lvalue1['aux_code']}"
}


'''
statement2 : SEMICOLON
'''

statement2 = { 'dim': 0, 'sizes': [], 'code': [], 'aux_code': '' }


'''
atribstat1 : expression
'''
atribstat1 = { 'atrib_type' : 'expr', 'node': expression['node'], 'code': expression['code'], 'label': expression['label'] }


'''
atribstat1 : allocexpression
'''
atribstat1 = { 'atrib_type' : 'alloc', 'alloc': allocexpression, 'code': allocexpression['code'], 'label': allocexpression['label'] }


'''
atribstat1 : funccall
'''
atribstat1 = { 'atrib_type' : 'funccall', 'function': funccall, 'code': funccall['code'], 'label': funccall['label'] }


'''
funccall : IDENT LPAREN paramlistcall RPAREN
'''

funccall = { 'code': [*paramlistcall['code'], "{tvar} = call {IDENT}, {len(paramlistcall['params'])}"], 'label': tvar }


'''
paramlistcall : factor paramlistcall2
'''

paramlistcall = { 'params': [var, *paramlistcall2['params']], 'code': [f"param {factor['label']}{paramlistcall2['aux_code']}", *paramlistcall2['code']] }


'''
paramlistcall : &
'''
paramlistcall = { 'params': [], 'code': [] }


'''
paramlistcall1 : COMMA paramlistcall
'''
paramlistcall = { 'params': paramlistcall['params'], 'code': paramlistcall['code'] }


'''
paramlistcall1 : &
'''
paramlistcall = { 'params': [], 'code': [] }


'''
paramlistcall2 : LBRACKET numexpression RBRACKET lvalue1 paramlistcall1
'''

paramlistcall2 = {
    'array': True,
    'dim': lvalue1['dim'] + 1,
    'sizes': [numexpression['node'], *lvalue1['sizes']],
    'params': paramlistcall1['params'],
    'code': [*numexpression['code'], *lvalue1['code'], *paramlistcall1['code']],
    'aux_code': "[{numexpression['label']}]{lvalue1['aux_code']}"
}


'''
paramlistcall2 : paramlistcall1
'''

paramlistcall2 = {
    'array': False,
    'code': paramlistcall1['code'],
    'params': paramlistcall1['params'],
    'aux_code': ''
}


'''
printstat : PRINT expression
'''

printstat = { 'code': [*expression['code'], "print {expression['label']}"] }


'''
readstat : READ expression
'''

readstat = { 'code': [*expression['code'], "read {expression['label']}"] }


'''
returnstat : RETURN returnstat1
'''

returnstat = { 'code': [*returnstat1['code'], "return {returnstat1['label']}"] }


'''
returnstat1 : expression
'''

returnstat1 = expression


'''
returnstat1 : &
'''

returnstat1 = { 'code': [], 'label': '' }


'''
ifstat : IF LPAREN expression RPAREN statement ifstat1
'''

end_if_label = generate_label()
if 'label' in ifstat1:
    next = ifstat1['label']

    ifstat = {
        'code': [
            *expression['code'],
            "if False {expression['label']} goto {next}",
            *statement['code'],
            "goto {end_if_label}",
            *ifstat1['code'],
            '{end_if_label}:'
        ]
    }
else:
    ifstat = {
        'code': [
            *expression['code'],
            "if False {expression['label']} goto {end_if_label}",
            *statement['code'],
            '{end_if_label}:'
        ]
    }


'''
ifstat1 : ELSE statement
'''

label = generate_label()
ifstat1 = {
    'code': [f'{label}:', *statement['code']],
    'label': label
}


'''
ifstat1 : &
'''

ifstat1 = { 'code': [] }


'''
forstat : new_loop_label FOR LPAREN forstat1-1 SEMICOLON forstat2 SEMICOLON forstat1-2 RPAREN new_scope_loop LBRACE statelist RBRACE
'''

scope_stack.pop()

start = generate_label()
next_label = NEXT_LOOP_LABEL

forstat = {
    'code': [
        *forstat1-1['code'],
        '{start}:',
        *forstat2['code'],
        *([f"if False {forstat2['label']} goto {next_label}"] if forstat2['label'] else []),
        *statelist['code'],
        *forstat1-2['code'],
        'goto {start}',
        '{next_label}:',
    ]
}


'''
forstat1 : IDENT forstat3
'''

search_var(IDENT, IDENT.lineno)
forstat1 = { 'code': [*forstat3['code'], "{IDENT} {forstat3['aux_code']}"] }


'''
forstat1 : &
'''

forstat1 = { 'code': [] }


'''
forstat2 : expression
'''

forstat2 = { 'code': expression['code'], 'label': expression['label'] }


'''
forstat2 : &
'''
forstat2 = { 'code': [], 'label': None }


'''
forstat3 : LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1
'''
forstat3 = { 
    'code': [*numexpression['code'], *lvalue1['code']], 
    'aux_code': "[{numexpression['label']}]{lvalue1['aux_code']} = {atribstat1['label']}" 
}


'''
forstat3 : ASSIGN atribstat1
'''
forstat3 = { 'code': atribstat1['code'], 'aux_code': "= {atribstat1['label']}" }


'''
whilestat : new_loop_label WHILE LPAREN expression RPAREN new_scope_loop LBRACE statelist RBRACE
'''

scope_stack.pop()

start = generate_label()
next = NEXT_LOOP_LABEL

whilestat = {
    'code': [
        '{start}:',
        *expression['code'],
        "if False {expression['label']} goto {next}",
        *statement['code'],
        'goto {start}',
        '{next}:',
    ]
}


'''
statelist : statement statelist1
'''

statelist = { 'code': [*statement['code'], *statelist1['code']] }

'''
statelist1 : statelist
'''

statelist1 = { 'code': statelist['code'] }


'''
statelist1 : &
'''

statelist1 = { 'code': [] }


'''
allocexpression : NEW types LBRACKET numexpression RBRACKET lvalue1
'''

num_expressions.append((numexpression['node'], numexpression.lineno))

var = get_var()

allocexpression = {
    'type': convert_type(types['type']),
    'dim': lvalue1['dim'] + 1,
    'label': var,
    'code': [*numexpression['code'], *lvalue1['code'], "{var} = new {types['code']}[{numexpression['label']}]{lvalue1['aux_code']}"], 
}

'''
expression : numexpression expression1
'''

if expression1['code']:
    rvar = get_var()
    expression = {
        'node': Node(expression1['operator'], numexpression['node'], expression1['node'], 'bool'),
        'label': rvar,
        'code': [
            *numexpression['code'],
            *expression1['code'],
            "{rvar} = {numexpression['label']}" + (f" {expression1['operator']} {expression1['label']}" if len(expression1['code']) > 0 else "")
        ]
    }
else:
    expression = numexpression

num_expressions.append((expression['node'], numexpression.lineno))

'''
expression1 : compoperator numexpression
'''
expression1 = { 
    'operator': compoperator,
    'node': numexpression['node'],
    'label': numexpression['label'],
    'code': numexpression['code']
}


'''
expression1 : &
'''
expression1 = { 'code': '' }

'''
compoperator : GT
'''

compoperator = '>'

'''
compoperator : LT
'''

compoperator = '<'

'''
compoperator : GE
'''
compoperator = '>='

'''
compoperator : LE
'''
compoperator = '<='

'''
compoperator : EQ
'''

compoperator = '=='

'''
compoperator : NEQ
'''

compoperator = '!='

'''
numexpression : term numexpression1
'''

if numexpression1['code']:
    rtype = check_type(term['node'], numexpression1['node'], numexpression1['operator'], term.lineno)

    var = get_var()
    numexpression = { 
        'node': Node(numexpression1['operator'], term['node'], numexpression1['node'], rtype),
        'code': [*term['code'], *numexpression1['code'], "{var} = {term['label']} {numexpression1['operator']} {numexpression1['label']}"],
        'label': var
    }
else:
    numexpression = term

'''
numexpression1 : addsub term
'''

numexpression1 = { 'node': term['node'], 'operator': addsub, 'code': term['code'], 'label': term['label'] }


'''
numexpression1 : &
'''

numexpression1 = { 'code': [] }

'''
addsub : PLUS
'''

addsub = '+'


'''
addsub : MINUS
'''

addsub = '-'


'''
term : unaryexpr term1
'''

if term1['code']:
    rtype = check_type(unaryexpr['node'], term1['node'], term1['operator'], unaryexpr.lineno)

    var = get_var()


    term = {
        'node': Node(term1['operator'], unaryexpr['node'], term1['node'], rtype),
        'code': [*unaryexpr['code'], "{var} = {unaryexpr['label']} {term1['operator']} {term1['label']}"],
        'label': var
    } 
else:
    term = unaryexpr


'''
term1 : multdiv unaryexpr term1
'''

if term1['code']:
    rtype = check_type(unaryexpr['node'], term1['node'], term1['operator'], unaryexpr.lineno)

    var = get_var()

    term1 = { 
        'node': Node(term1['operator'], unaryexpr['node'], term1['node'], rtype), 
        'operator': multdiv,
        'code': [*unaryexpr['code'], *term1['code'], "{var} = {unaryexpr['label']} {term1['operator']} {term1['label']}"],
        'label': var
    }
else:
    term1 = { 'node': unaryexpr['node'], 'operator': multdiv, 'code': unaryexpr['code'], 'label': unaryexpr['label'] }

'''
term1 : &
'''

term1 = { 'code': [] }

'''
multdiv : MULTIPLY
'''

multdiv = '*'

'''
multdiv : DIVIDE
'''

multdiv = '/'

'''
multdiv : REM
'''

multdiv = '%'

'''
unaryexpr : addsub factor
'''
if (addsub == '-'):
    factor['node'].value *= -1

var = get_var()

unaryexpr = { 'node': factor['node'], 'code': [*factor['code'], *([f"{var} = {addsub}{factor['label']}"] if addsub == '-' else [])], 'label': var }


'''
unaryexpr : factor
'''

unaryexpr = factor


'''
factor : int_constant
'''
var = get_var()

factor = { 'node': Node(int_constant, None, None, 'int'), 'code': [f'{var} = {int_constant}'], 'label': var }


'''
factor : float_constant
'''

var = get_var()

factor = { 'node': Node(float_constant, None, None, 'float'), 'code': [f'{var} = {float_constant}'], 'label': var  }


'''
factor : string_constant
'''

var = get_var()

factor = { 'node': Node(string_constant, None, None, 'string'), 'code': [f'{var} = {string_constant}'], 'label': var  }


'''
factor : null_constant
'''

var = get_var()

factor = { 'node': Node('null', None, None, 'null'), 'code': ['{var} = null'], 'label': var }

'''
factor : IDENT lvalue1
'''

var = search_var(IDENT, IDENT.lineno)
nvar = get_var()

factor = {
    'node': Node(IDENT + lvalue1['expression'], None, None, type2str(var.type, var.dimension, lvalue1['dim'])),
    'code': [f"{nvar} = {IDENT}{lvalue1['aux_code']}"],
    'label': nvar,
    'vartype': 'ident'
}

'''
factor : LPAREN numexpression RPAREN
'''
factor = numexpression

num_expressions.append((numexpression['node'], numexpression.lineno))

'''
lvalue1 : LBRACKET numexpression RBRACKET lvalue1
'''
lvalue1 = {
    'dim': lvalue1['dim'] + 1,
    'sizes': [numexpression['node'], *lvalue1['sizes']],
    'expression': '[{numexpression}]{lvalue1}',
    'code': [*numexpression['code'], *lvalue1['code']],
    'aux_code': "[{numexpression['label']}]{lvalue1['aux_code']}"
}

num_expressions.append((numexpression['node'], numexpression.lineno))

'''
lvalue1 : &
'''
lvalue1 = {
    'dim': 0,
    'sizes': [],
    'expression': '',
    'code': [],
    'aux_code': ''
}

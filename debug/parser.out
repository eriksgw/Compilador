Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> funclist
Rule 3     program -> <empty>
Rule 4     funclist -> funcdef funclist1
Rule 5     funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1
Rule 6     funclist1 -> <empty>
Rule 7     funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE
Rule 8     types -> INT
Rule 9     types -> FLOAT
Rule 10    types -> STRING
Rule 11    paramlist -> STRING listdcl IDENT paramlist1
Rule 12    paramlist -> FLOAT listdcl IDENT paramlist1
Rule 13    paramlist -> INT listdcl IDENT paramlist1
Rule 14    paramlist -> <empty>
Rule 15    paramlist1 -> COMMA paramlist
Rule 16    paramlist1 -> <empty>
Rule 17    listdcl -> LBRACKET RBRACKET listdcl
Rule 18    listdcl -> <empty>
Rule 19    statement -> INT IDENT statement2
Rule 20    statement -> FLOAT IDENT statement2
Rule 21    statement -> STRING IDENT statement2
Rule 22    statement -> IDENT statement1
Rule 23    statement -> printstat SEMICOLON
Rule 24    statement -> readstat SEMICOLON
Rule 25    statement -> returnstat SEMICOLON
Rule 26    statement -> ifstat
Rule 27    statement -> forstat
Rule 28    statement -> whilestat
Rule 29    statement -> LBRACE statelist RBRACE
Rule 30    statement -> BREAK SEMICOLON
Rule 31    statement -> SEMICOLON
Rule 32    statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON
Rule 33    statement1 -> ASSIGN atribstat1 SEMICOLON
Rule 34    statement1 -> LPAREN paramlistcall RPAREN SEMICOLON
Rule 35    statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON
Rule 36    statement2 -> SEMICOLON
Rule 37    atribstat1 -> expression
Rule 38    atribstat1 -> allocexpression
Rule 39    atribstat1 -> funccall
Rule 40    funccall -> IDENT LPAREN paramlistcall RPAREN
Rule 41    paramlistcall -> factor paramlistcall2
Rule 42    paramlistcall -> <empty>
Rule 43    paramlistcall1 -> COMMA paramlistcall
Rule 44    paramlistcall1 -> <empty>
Rule 45    paramlistcall2 -> LBRACKET numexpression RBRACKET lvalue1 paramlistcall1
Rule 46    paramlistcall2 -> paramlistcall1
Rule 47    printstat -> PRINT expression
Rule 48    readstat -> READ expression
Rule 49    returnstat -> RETURN returnstat1
Rule 50    returnstat1 -> expression
Rule 51    returnstat1 -> <empty>
Rule 52    ifstat -> IF LPAREN expression RPAREN statement ifstat1
Rule 53    ifstat1 -> ELSE statement
Rule 54    ifstat1 -> <empty>
Rule 55    forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
Rule 56    forstat1 -> IDENT forstat3
Rule 57    forstat1 -> <empty>
Rule 58    forstat2 -> expression
Rule 59    forstat2 -> <empty>
Rule 60    forstat3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1
Rule 61    forstat3 -> ASSIGN atribstat1
Rule 62    whilestat -> WHILE LPAREN expression RPAREN statement
Rule 63    statelist -> INT listdcl IDENT statelist2
Rule 64    statelist -> FLOAT listdcl IDENT statelist2
Rule 65    statelist -> STRING listdcl IDENT statelist2
Rule 66    statelist -> IDENT statelist3
Rule 67    statelist -> PRINT expression SEMICOLON statelist1
Rule 68    statelist -> READ IDENT statelist2
Rule 69    statelist -> RETURN returnstat1 SEMICOLON statelist1
Rule 70    statelist -> IF LPAREN expression RPAREN statement ifstat1 statelist1
Rule 71    statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
Rule 72    statelist -> WHILE LPAREN expression RPAREN statement statelist1
Rule 73    statelist -> LBRACE statelist RBRACE statelist1
Rule 74    statelist -> BREAK SEMICOLON statelist1
Rule 75    statelist -> SEMICOLON statelist1
Rule 76    statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
Rule 77    statelist1 -> INT listdcl IDENT statelist2
Rule 78    statelist1 -> FLOAT listdcl IDENT statelist2
Rule 79    statelist1 -> STRING listdcl IDENT statelist2
Rule 80    statelist1 -> IDENT statelist3
Rule 81    statelist1 -> PRINT expression SEMICOLON statelist1
Rule 82    statelist1 -> READ IDENT statelist2
Rule 83    statelist1 -> RETURN returnstat1 SEMICOLON statelist1
Rule 84    statelist1 -> IF LPAREN expression RPAREN statement ifstat1 statelist1
Rule 85    statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
Rule 86    statelist1 -> WHILE LPAREN expression RPAREN statement statelist1
Rule 87    statelist1 -> LBRACE statelist RBRACE statelist1
Rule 88    statelist1 -> BREAK SEMICOLON statelist1
Rule 89    statelist1 -> SEMICOLON statelist1
Rule 90    statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
Rule 91    statelist1 -> <empty>
Rule 92    statelist2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
Rule 93    statelist2 -> SEMICOLON statelist1
Rule 94    statelist3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON statelist1
Rule 95    statelist3 -> ASSIGN atribstat1 SEMICOLON statelist1
Rule 96    allocexpression -> NEW types LBRACKET numexpression RBRACKET lvalue1
Rule 97    expression -> numexpression expression1
Rule 98    expression1 -> compoperator numexpression
Rule 99    expression1 -> <empty>
Rule 100   compoperator -> GT
Rule 101   compoperator -> LT
Rule 102   compoperator -> GE
Rule 103   compoperator -> LE
Rule 104   compoperator -> EQ
Rule 105   compoperator -> NEQ
Rule 106   numexpression -> term numexpression1
Rule 107   numexpression1 -> addsub term
Rule 108   numexpression1 -> <empty>
Rule 109   addsub -> PLUS
Rule 110   addsub -> MINUS
Rule 111   term -> unaryexpr term1
Rule 112   term1 -> multdiv unaryexpr term1
Rule 113   term1 -> <empty>
Rule 114   multdiv -> MULTIPLY
Rule 115   multdiv -> DIVIDE
Rule 116   multdiv -> REM
Rule 117   unaryexpr -> addsub factor
Rule 118   unaryexpr -> factor
Rule 119   factor -> int_constant
Rule 120   factor -> float_constant
Rule 121   factor -> string_constant
Rule 122   factor -> null_constant
Rule 123   factor -> IDENT lvalue1
Rule 124   factor -> LPAREN numexpression RPAREN
Rule 125   lvalue1 -> LBRACKET numexpression RBRACKET lvalue1
Rule 126   lvalue1 -> <empty>

Terminals, with rules where they appear

ASSIGN               : 32 33 60 61 94 95
BREAK                : 30 74 88
COMMA                : 15 43
DEF                  : 5 7
DIVIDE               : 115
ELSE                 : 53
EQ                   : 104
FLOAT                : 9 12 20 64 78
FOR                  : 55 71 85
GE                   : 102
GT                   : 100
IDENT                : 5 7 11 12 13 19 20 21 22 40 56 63 64 65 66 68 76 77 78 79 80 82 90 123
IF                   : 52 70 84
INT                  : 8 13 19 63 77
LBRACE               : 5 7 29 73 87
LBRACKET             : 17 32 35 45 60 92 94 96 125
LE                   : 103
LPAREN               : 5 7 34 40 52 55 62 70 71 72 76 84 85 86 90 124
LT                   : 101
MINUS                : 110
MULTIPLY             : 114
NEQ                  : 105
NEW                  : 96
PLUS                 : 109
PRINT                : 47 67 81
RBRACE               : 5 7 29 73 87
RBRACKET             : 17 32 35 45 60 92 94 96 125
READ                 : 48 68 82
REM                  : 116
RETURN               : 49 69 83
RPAREN               : 5 7 34 40 52 55 62 70 71 72 76 84 85 86 90 124
SEMICOLON            : 23 24 25 30 31 32 33 34 35 36 55 55 67 69 71 71 74 75 76 81 83 85 85 88 89 90 92 93 94 95
STRING               : 10 11 21 65 79
WHILE                : 62 72 86
error                : 
float_constant       : 120
int_constant         : 119
null_constant        : 122
string_constant      : 121

Nonterminals, with rules where they appear

addsub               : 107 117
allocexpression      : 38
atribstat1           : 32 33 60 61 94 95
compoperator         : 98
expression           : 37 47 48 50 52 58 62 67 70 72 81 84 86
expression1          : 97
factor               : 41 117 118
forstat              : 27
forstat1             : 55 55 71 71 85 85
forstat2             : 55 71 85
forstat3             : 56
funccall             : 39
funcdef              : 4
funclist             : 2
funclist1            : 4 5
ifstat               : 26
ifstat1              : 52 70 84
listdcl              : 11 12 13 17 63 64 65 77 78 79
lvalue1              : 32 35 45 60 92 94 96 123 125
multdiv              : 112
numexpression        : 32 35 45 60 92 94 96 97 98 124 125
numexpression1       : 106
paramlist            : 5 7 15
paramlist1           : 11 12 13
paramlistcall        : 34 40 43 76 90
paramlistcall1       : 45 46
paramlistcall2       : 41
printstat            : 23
program              : 0
readstat             : 24
returnstat           : 25
returnstat1          : 49 69 83
statelist            : 5 7 29 73 87
statelist1           : 67 69 70 71 72 73 74 75 76 81 83 84 85 86 87 88 89 90 92 93 94 95
statelist2           : 63 64 65 68 77 78 79 82
statelist3           : 66 80
statement            : 1 52 53 55 62 70 71 72 84 85 86
statement1           : 22
statement2           : 19 20 21
term                 : 106 107
term1                : 111 112
types                : 96
unaryexpr            : 111 112
whilestat            : 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . funclist
    (3) program -> .
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (4) funclist -> . funcdef funclist1
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement
    (7) funcdef -> . DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE

    $end            reduce using rule 3 (program -> .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23
    DEF             shift and go to state 24

    program                        shift and go to state 1
    statement                      shift and go to state 2
    funclist                       shift and go to state 3
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14
    funcdef                        shift and go to state 17

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) program -> funclist .

    $end            reduce using rule 2 (program -> funclist .)


state 4

    (19) statement -> INT . IDENT statement2

    IDENT           shift and go to state 25


state 5

    (22) statement -> IDENT . statement1
    (32) statement1 -> . LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON
    (33) statement1 -> . ASSIGN atribstat1 SEMICOLON
    (34) statement1 -> . LPAREN paramlistcall RPAREN SEMICOLON

    LBRACKET        shift and go to state 27
    ASSIGN          shift and go to state 28
    LPAREN          shift and go to state 29

    statement1                     shift and go to state 26

state 6

    (20) statement -> FLOAT . IDENT statement2

    IDENT           shift and go to state 30


state 7

    (21) statement -> STRING . IDENT statement2

    IDENT           shift and go to state 31


state 8

    (23) statement -> printstat . SEMICOLON

    SEMICOLON       shift and go to state 32


state 9

    (31) statement -> SEMICOLON .

    $end            reduce using rule 31 (statement -> SEMICOLON .)
    ELSE            reduce using rule 31 (statement -> SEMICOLON .)
    INT             reduce using rule 31 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 31 (statement -> SEMICOLON .)
    STRING          reduce using rule 31 (statement -> SEMICOLON .)
    IDENT           reduce using rule 31 (statement -> SEMICOLON .)
    PRINT           reduce using rule 31 (statement -> SEMICOLON .)
    READ            reduce using rule 31 (statement -> SEMICOLON .)
    RETURN          reduce using rule 31 (statement -> SEMICOLON .)
    IF              reduce using rule 31 (statement -> SEMICOLON .)
    FOR             reduce using rule 31 (statement -> SEMICOLON .)
    WHILE           reduce using rule 31 (statement -> SEMICOLON .)
    LBRACE          reduce using rule 31 (statement -> SEMICOLON .)
    BREAK           reduce using rule 31 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 31 (statement -> SEMICOLON .)
    RBRACE          reduce using rule 31 (statement -> SEMICOLON .)


state 10

    (24) statement -> readstat . SEMICOLON

    SEMICOLON       shift and go to state 33


state 11

    (25) statement -> returnstat . SEMICOLON

    SEMICOLON       shift and go to state 34


state 12

    (26) statement -> ifstat .

    $end            reduce using rule 26 (statement -> ifstat .)
    ELSE            reduce using rule 26 (statement -> ifstat .)
    INT             reduce using rule 26 (statement -> ifstat .)
    FLOAT           reduce using rule 26 (statement -> ifstat .)
    STRING          reduce using rule 26 (statement -> ifstat .)
    IDENT           reduce using rule 26 (statement -> ifstat .)
    PRINT           reduce using rule 26 (statement -> ifstat .)
    READ            reduce using rule 26 (statement -> ifstat .)
    RETURN          reduce using rule 26 (statement -> ifstat .)
    IF              reduce using rule 26 (statement -> ifstat .)
    FOR             reduce using rule 26 (statement -> ifstat .)
    WHILE           reduce using rule 26 (statement -> ifstat .)
    LBRACE          reduce using rule 26 (statement -> ifstat .)
    BREAK           reduce using rule 26 (statement -> ifstat .)
    SEMICOLON       reduce using rule 26 (statement -> ifstat .)
    RBRACE          reduce using rule 26 (statement -> ifstat .)


state 13

    (27) statement -> forstat .

    $end            reduce using rule 27 (statement -> forstat .)
    ELSE            reduce using rule 27 (statement -> forstat .)
    INT             reduce using rule 27 (statement -> forstat .)
    FLOAT           reduce using rule 27 (statement -> forstat .)
    STRING          reduce using rule 27 (statement -> forstat .)
    IDENT           reduce using rule 27 (statement -> forstat .)
    PRINT           reduce using rule 27 (statement -> forstat .)
    READ            reduce using rule 27 (statement -> forstat .)
    RETURN          reduce using rule 27 (statement -> forstat .)
    IF              reduce using rule 27 (statement -> forstat .)
    FOR             reduce using rule 27 (statement -> forstat .)
    WHILE           reduce using rule 27 (statement -> forstat .)
    LBRACE          reduce using rule 27 (statement -> forstat .)
    BREAK           reduce using rule 27 (statement -> forstat .)
    SEMICOLON       reduce using rule 27 (statement -> forstat .)
    RBRACE          reduce using rule 27 (statement -> forstat .)


state 14

    (28) statement -> whilestat .

    $end            reduce using rule 28 (statement -> whilestat .)
    ELSE            reduce using rule 28 (statement -> whilestat .)
    INT             reduce using rule 28 (statement -> whilestat .)
    FLOAT           reduce using rule 28 (statement -> whilestat .)
    STRING          reduce using rule 28 (statement -> whilestat .)
    IDENT           reduce using rule 28 (statement -> whilestat .)
    PRINT           reduce using rule 28 (statement -> whilestat .)
    READ            reduce using rule 28 (statement -> whilestat .)
    RETURN          reduce using rule 28 (statement -> whilestat .)
    IF              reduce using rule 28 (statement -> whilestat .)
    FOR             reduce using rule 28 (statement -> whilestat .)
    WHILE           reduce using rule 28 (statement -> whilestat .)
    LBRACE          reduce using rule 28 (statement -> whilestat .)
    BREAK           reduce using rule 28 (statement -> whilestat .)
    SEMICOLON       reduce using rule 28 (statement -> whilestat .)
    RBRACE          reduce using rule 28 (statement -> whilestat .)


state 15

    (29) statement -> LBRACE . statelist RBRACE
    (63) statelist -> . INT listdcl IDENT statelist2
    (64) statelist -> . FLOAT listdcl IDENT statelist2
    (65) statelist -> . STRING listdcl IDENT statelist2
    (66) statelist -> . IDENT statelist3
    (67) statelist -> . PRINT expression SEMICOLON statelist1
    (68) statelist -> . READ IDENT statelist2
    (69) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (70) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (71) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (72) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (73) statelist -> . LBRACE statelist RBRACE statelist1
    (74) statelist -> . BREAK SEMICOLON statelist1
    (75) statelist -> . SEMICOLON statelist1
    (76) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 37
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 38
    PRINT           shift and go to state 41
    READ            shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    FOR             shift and go to state 46
    WHILE           shift and go to state 47
    LBRACE          shift and go to state 35
    BREAK           shift and go to state 48
    SEMICOLON       shift and go to state 42

    statelist                      shift and go to state 36

state 16

    (30) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 49


state 17

    (4) funclist -> funcdef . funclist1
    (5) funclist1 -> . DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1
    (6) funclist1 -> .

    DEF             shift and go to state 51
    $end            reduce using rule 6 (funclist1 -> .)

    funclist1                      shift and go to state 50

state 18

    (47) printstat -> PRINT . expression
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 52
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 19

    (48) readstat -> READ . expression
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 66
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 20

    (49) returnstat -> RETURN . returnstat1
    (50) returnstat1 -> . expression
    (51) returnstat1 -> .
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 51 (returnstat1 -> .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    returnstat1                    shift and go to state 67
    expression                     shift and go to state 68
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 21

    (52) ifstat -> IF . LPAREN expression RPAREN statement ifstat1

    LPAREN          shift and go to state 69


state 22

    (55) forstat -> FOR . LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement

    LPAREN          shift and go to state 70


state 23

    (62) whilestat -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 71


state 24

    (7) funcdef -> DEF . IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE

    IDENT           shift and go to state 72


state 25

    (19) statement -> INT IDENT . statement2
    (35) statement2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON
    (36) statement2 -> . SEMICOLON

    LBRACKET        shift and go to state 74
    SEMICOLON       shift and go to state 75

    statement2                     shift and go to state 73

state 26

    (22) statement -> IDENT statement1 .

    $end            reduce using rule 22 (statement -> IDENT statement1 .)
    ELSE            reduce using rule 22 (statement -> IDENT statement1 .)
    INT             reduce using rule 22 (statement -> IDENT statement1 .)
    FLOAT           reduce using rule 22 (statement -> IDENT statement1 .)
    STRING          reduce using rule 22 (statement -> IDENT statement1 .)
    IDENT           reduce using rule 22 (statement -> IDENT statement1 .)
    PRINT           reduce using rule 22 (statement -> IDENT statement1 .)
    READ            reduce using rule 22 (statement -> IDENT statement1 .)
    RETURN          reduce using rule 22 (statement -> IDENT statement1 .)
    IF              reduce using rule 22 (statement -> IDENT statement1 .)
    FOR             reduce using rule 22 (statement -> IDENT statement1 .)
    WHILE           reduce using rule 22 (statement -> IDENT statement1 .)
    LBRACE          reduce using rule 22 (statement -> IDENT statement1 .)
    BREAK           reduce using rule 22 (statement -> IDENT statement1 .)
    SEMICOLON       reduce using rule 22 (statement -> IDENT statement1 .)
    RBRACE          reduce using rule 22 (statement -> IDENT statement1 .)


state 27

    (32) statement1 -> LBRACKET . numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 76
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 28

    (33) statement1 -> ASSIGN . atribstat1 SEMICOLON
    (37) atribstat1 -> . expression
    (38) atribstat1 -> . allocexpression
    (39) atribstat1 -> . funccall
    (97) expression -> . numexpression expression1
    (96) allocexpression -> . NEW types LBRACKET numexpression RBRACKET lvalue1
    (40) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 81
    IDENT           shift and go to state 82
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    LPAREN          shift and go to state 65

    atribstat1                     shift and go to state 77
    expression                     shift and go to state 78
    allocexpression                shift and go to state 79
    funccall                       shift and go to state 80
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 29

    (34) statement1 -> LPAREN . paramlistcall RPAREN SEMICOLON
    (41) paramlistcall -> . factor paramlistcall2
    (42) paramlistcall -> .
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    RPAREN          reduce using rule 42 (paramlistcall -> .)
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    paramlistcall                  shift and go to state 83
    factor                         shift and go to state 84

state 30

    (20) statement -> FLOAT IDENT . statement2
    (35) statement2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON
    (36) statement2 -> . SEMICOLON

    LBRACKET        shift and go to state 74
    SEMICOLON       shift and go to state 75

    statement2                     shift and go to state 85

state 31

    (21) statement -> STRING IDENT . statement2
    (35) statement2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON
    (36) statement2 -> . SEMICOLON

    LBRACKET        shift and go to state 74
    SEMICOLON       shift and go to state 75

    statement2                     shift and go to state 86

state 32

    (23) statement -> printstat SEMICOLON .

    $end            reduce using rule 23 (statement -> printstat SEMICOLON .)
    ELSE            reduce using rule 23 (statement -> printstat SEMICOLON .)
    INT             reduce using rule 23 (statement -> printstat SEMICOLON .)
    FLOAT           reduce using rule 23 (statement -> printstat SEMICOLON .)
    STRING          reduce using rule 23 (statement -> printstat SEMICOLON .)
    IDENT           reduce using rule 23 (statement -> printstat SEMICOLON .)
    PRINT           reduce using rule 23 (statement -> printstat SEMICOLON .)
    READ            reduce using rule 23 (statement -> printstat SEMICOLON .)
    RETURN          reduce using rule 23 (statement -> printstat SEMICOLON .)
    IF              reduce using rule 23 (statement -> printstat SEMICOLON .)
    FOR             reduce using rule 23 (statement -> printstat SEMICOLON .)
    WHILE           reduce using rule 23 (statement -> printstat SEMICOLON .)
    LBRACE          reduce using rule 23 (statement -> printstat SEMICOLON .)
    BREAK           reduce using rule 23 (statement -> printstat SEMICOLON .)
    SEMICOLON       reduce using rule 23 (statement -> printstat SEMICOLON .)
    RBRACE          reduce using rule 23 (statement -> printstat SEMICOLON .)


state 33

    (24) statement -> readstat SEMICOLON .

    $end            reduce using rule 24 (statement -> readstat SEMICOLON .)
    ELSE            reduce using rule 24 (statement -> readstat SEMICOLON .)
    INT             reduce using rule 24 (statement -> readstat SEMICOLON .)
    FLOAT           reduce using rule 24 (statement -> readstat SEMICOLON .)
    STRING          reduce using rule 24 (statement -> readstat SEMICOLON .)
    IDENT           reduce using rule 24 (statement -> readstat SEMICOLON .)
    PRINT           reduce using rule 24 (statement -> readstat SEMICOLON .)
    READ            reduce using rule 24 (statement -> readstat SEMICOLON .)
    RETURN          reduce using rule 24 (statement -> readstat SEMICOLON .)
    IF              reduce using rule 24 (statement -> readstat SEMICOLON .)
    FOR             reduce using rule 24 (statement -> readstat SEMICOLON .)
    WHILE           reduce using rule 24 (statement -> readstat SEMICOLON .)
    LBRACE          reduce using rule 24 (statement -> readstat SEMICOLON .)
    BREAK           reduce using rule 24 (statement -> readstat SEMICOLON .)
    SEMICOLON       reduce using rule 24 (statement -> readstat SEMICOLON .)
    RBRACE          reduce using rule 24 (statement -> readstat SEMICOLON .)


state 34

    (25) statement -> returnstat SEMICOLON .

    $end            reduce using rule 25 (statement -> returnstat SEMICOLON .)
    ELSE            reduce using rule 25 (statement -> returnstat SEMICOLON .)
    INT             reduce using rule 25 (statement -> returnstat SEMICOLON .)
    FLOAT           reduce using rule 25 (statement -> returnstat SEMICOLON .)
    STRING          reduce using rule 25 (statement -> returnstat SEMICOLON .)
    IDENT           reduce using rule 25 (statement -> returnstat SEMICOLON .)
    PRINT           reduce using rule 25 (statement -> returnstat SEMICOLON .)
    READ            reduce using rule 25 (statement -> returnstat SEMICOLON .)
    RETURN          reduce using rule 25 (statement -> returnstat SEMICOLON .)
    IF              reduce using rule 25 (statement -> returnstat SEMICOLON .)
    FOR             reduce using rule 25 (statement -> returnstat SEMICOLON .)
    WHILE           reduce using rule 25 (statement -> returnstat SEMICOLON .)
    LBRACE          reduce using rule 25 (statement -> returnstat SEMICOLON .)
    BREAK           reduce using rule 25 (statement -> returnstat SEMICOLON .)
    SEMICOLON       reduce using rule 25 (statement -> returnstat SEMICOLON .)
    RBRACE          reduce using rule 25 (statement -> returnstat SEMICOLON .)


state 35

    (73) statelist -> LBRACE . statelist RBRACE statelist1
    (63) statelist -> . INT listdcl IDENT statelist2
    (64) statelist -> . FLOAT listdcl IDENT statelist2
    (65) statelist -> . STRING listdcl IDENT statelist2
    (66) statelist -> . IDENT statelist3
    (67) statelist -> . PRINT expression SEMICOLON statelist1
    (68) statelist -> . READ IDENT statelist2
    (69) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (70) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (71) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (72) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (73) statelist -> . LBRACE statelist RBRACE statelist1
    (74) statelist -> . BREAK SEMICOLON statelist1
    (75) statelist -> . SEMICOLON statelist1
    (76) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 37
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 38
    PRINT           shift and go to state 41
    READ            shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    FOR             shift and go to state 46
    WHILE           shift and go to state 47
    LBRACE          shift and go to state 35
    BREAK           shift and go to state 48
    SEMICOLON       shift and go to state 42

    statelist                      shift and go to state 87

state 36

    (29) statement -> LBRACE statelist . RBRACE

    RBRACE          shift and go to state 88


state 37

    (63) statelist -> INT . listdcl IDENT statelist2
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 89

state 38

    (66) statelist -> IDENT . statelist3
    (76) statelist -> IDENT . LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (94) statelist3 -> . LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON statelist1
    (95) statelist3 -> . ASSIGN atribstat1 SEMICOLON statelist1

    LPAREN          shift and go to state 92
    LBRACKET        shift and go to state 93
    ASSIGN          shift and go to state 94

    statelist3                     shift and go to state 91

state 39

    (64) statelist -> FLOAT . listdcl IDENT statelist2
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 95

state 40

    (65) statelist -> STRING . listdcl IDENT statelist2
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 96

state 41

    (67) statelist -> PRINT . expression SEMICOLON statelist1
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 97
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 42

    (75) statelist -> SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 99

state 43

    (68) statelist -> READ . IDENT statelist2

    IDENT           shift and go to state 112


state 44

    (69) statelist -> RETURN . returnstat1 SEMICOLON statelist1
    (50) returnstat1 -> . expression
    (51) returnstat1 -> .
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 51 (returnstat1 -> .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    returnstat1                    shift and go to state 113
    expression                     shift and go to state 68
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 45

    (70) statelist -> IF . LPAREN expression RPAREN statement ifstat1 statelist1

    LPAREN          shift and go to state 114


state 46

    (71) statelist -> FOR . LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    LPAREN          shift and go to state 115


state 47

    (72) statelist -> WHILE . LPAREN expression RPAREN statement statelist1

    LPAREN          shift and go to state 116


state 48

    (74) statelist -> BREAK . SEMICOLON statelist1

    SEMICOLON       shift and go to state 117


state 49

    (30) statement -> BREAK SEMICOLON .

    $end            reduce using rule 30 (statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 30 (statement -> BREAK SEMICOLON .)
    INT             reduce using rule 30 (statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 30 (statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 30 (statement -> BREAK SEMICOLON .)
    IDENT           reduce using rule 30 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 30 (statement -> BREAK SEMICOLON .)
    READ            reduce using rule 30 (statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 30 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 30 (statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 30 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 30 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 30 (statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 30 (statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 30 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 30 (statement -> BREAK SEMICOLON .)


state 50

    (4) funclist -> funcdef funclist1 .

    $end            reduce using rule 4 (funclist -> funcdef funclist1 .)


state 51

    (5) funclist1 -> DEF . IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1

    IDENT           shift and go to state 118


state 52

    (47) printstat -> PRINT expression .

    SEMICOLON       reduce using rule 47 (printstat -> PRINT expression .)


state 53

    (97) expression -> numexpression . expression1
    (98) expression1 -> . compoperator numexpression
    (99) expression1 -> .
    (100) compoperator -> . GT
    (101) compoperator -> . LT
    (102) compoperator -> . GE
    (103) compoperator -> . LE
    (104) compoperator -> . EQ
    (105) compoperator -> . NEQ

    SEMICOLON       reduce using rule 99 (expression1 -> .)
    RPAREN          reduce using rule 99 (expression1 -> .)
    GT              shift and go to state 121
    LT              shift and go to state 122
    GE              shift and go to state 123
    LE              shift and go to state 124
    EQ              shift and go to state 125
    NEQ             shift and go to state 126

    expression1                    shift and go to state 119
    compoperator                   shift and go to state 120

state 54

    (106) numexpression -> term . numexpression1
    (107) numexpression1 -> . addsub term
    (108) numexpression1 -> .
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS

    GT              reduce using rule 108 (numexpression1 -> .)
    LT              reduce using rule 108 (numexpression1 -> .)
    GE              reduce using rule 108 (numexpression1 -> .)
    LE              reduce using rule 108 (numexpression1 -> .)
    EQ              reduce using rule 108 (numexpression1 -> .)
    NEQ             reduce using rule 108 (numexpression1 -> .)
    SEMICOLON       reduce using rule 108 (numexpression1 -> .)
    RBRACKET        reduce using rule 108 (numexpression1 -> .)
    RPAREN          reduce using rule 108 (numexpression1 -> .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    numexpression1                 shift and go to state 127
    addsub                         shift and go to state 128

state 55

    (111) term -> unaryexpr . term1
    (112) term1 -> . multdiv unaryexpr term1
    (113) term1 -> .
    (114) multdiv -> . MULTIPLY
    (115) multdiv -> . DIVIDE
    (116) multdiv -> . REM

    PLUS            reduce using rule 113 (term1 -> .)
    MINUS           reduce using rule 113 (term1 -> .)
    GT              reduce using rule 113 (term1 -> .)
    LT              reduce using rule 113 (term1 -> .)
    GE              reduce using rule 113 (term1 -> .)
    LE              reduce using rule 113 (term1 -> .)
    EQ              reduce using rule 113 (term1 -> .)
    NEQ             reduce using rule 113 (term1 -> .)
    SEMICOLON       reduce using rule 113 (term1 -> .)
    RBRACKET        reduce using rule 113 (term1 -> .)
    RPAREN          reduce using rule 113 (term1 -> .)
    MULTIPLY        shift and go to state 131
    DIVIDE          shift and go to state 132
    REM             shift and go to state 133

    term1                          shift and go to state 129
    multdiv                        shift and go to state 130

state 56

    (117) unaryexpr -> addsub . factor
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    factor                         shift and go to state 134

state 57

    (118) unaryexpr -> factor .

    MULTIPLY        reduce using rule 118 (unaryexpr -> factor .)
    DIVIDE          reduce using rule 118 (unaryexpr -> factor .)
    REM             reduce using rule 118 (unaryexpr -> factor .)
    PLUS            reduce using rule 118 (unaryexpr -> factor .)
    MINUS           reduce using rule 118 (unaryexpr -> factor .)
    GT              reduce using rule 118 (unaryexpr -> factor .)
    LT              reduce using rule 118 (unaryexpr -> factor .)
    GE              reduce using rule 118 (unaryexpr -> factor .)
    LE              reduce using rule 118 (unaryexpr -> factor .)
    EQ              reduce using rule 118 (unaryexpr -> factor .)
    NEQ             reduce using rule 118 (unaryexpr -> factor .)
    SEMICOLON       reduce using rule 118 (unaryexpr -> factor .)
    RBRACKET        reduce using rule 118 (unaryexpr -> factor .)
    RPAREN          reduce using rule 118 (unaryexpr -> factor .)


state 58

    (109) addsub -> PLUS .

    int_constant    reduce using rule 109 (addsub -> PLUS .)
    float_constant  reduce using rule 109 (addsub -> PLUS .)
    string_constant reduce using rule 109 (addsub -> PLUS .)
    null_constant   reduce using rule 109 (addsub -> PLUS .)
    IDENT           reduce using rule 109 (addsub -> PLUS .)
    LPAREN          reduce using rule 109 (addsub -> PLUS .)
    PLUS            reduce using rule 109 (addsub -> PLUS .)
    MINUS           reduce using rule 109 (addsub -> PLUS .)


state 59

    (110) addsub -> MINUS .

    int_constant    reduce using rule 110 (addsub -> MINUS .)
    float_constant  reduce using rule 110 (addsub -> MINUS .)
    string_constant reduce using rule 110 (addsub -> MINUS .)
    null_constant   reduce using rule 110 (addsub -> MINUS .)
    IDENT           reduce using rule 110 (addsub -> MINUS .)
    LPAREN          reduce using rule 110 (addsub -> MINUS .)
    PLUS            reduce using rule 110 (addsub -> MINUS .)
    MINUS           reduce using rule 110 (addsub -> MINUS .)


state 60

    (119) factor -> int_constant .

    MULTIPLY        reduce using rule 119 (factor -> int_constant .)
    DIVIDE          reduce using rule 119 (factor -> int_constant .)
    REM             reduce using rule 119 (factor -> int_constant .)
    PLUS            reduce using rule 119 (factor -> int_constant .)
    MINUS           reduce using rule 119 (factor -> int_constant .)
    GT              reduce using rule 119 (factor -> int_constant .)
    LT              reduce using rule 119 (factor -> int_constant .)
    GE              reduce using rule 119 (factor -> int_constant .)
    LE              reduce using rule 119 (factor -> int_constant .)
    EQ              reduce using rule 119 (factor -> int_constant .)
    NEQ             reduce using rule 119 (factor -> int_constant .)
    SEMICOLON       reduce using rule 119 (factor -> int_constant .)
    RBRACKET        reduce using rule 119 (factor -> int_constant .)
    LBRACKET        reduce using rule 119 (factor -> int_constant .)
    COMMA           reduce using rule 119 (factor -> int_constant .)
    RPAREN          reduce using rule 119 (factor -> int_constant .)


state 61

    (120) factor -> float_constant .

    MULTIPLY        reduce using rule 120 (factor -> float_constant .)
    DIVIDE          reduce using rule 120 (factor -> float_constant .)
    REM             reduce using rule 120 (factor -> float_constant .)
    PLUS            reduce using rule 120 (factor -> float_constant .)
    MINUS           reduce using rule 120 (factor -> float_constant .)
    GT              reduce using rule 120 (factor -> float_constant .)
    LT              reduce using rule 120 (factor -> float_constant .)
    GE              reduce using rule 120 (factor -> float_constant .)
    LE              reduce using rule 120 (factor -> float_constant .)
    EQ              reduce using rule 120 (factor -> float_constant .)
    NEQ             reduce using rule 120 (factor -> float_constant .)
    SEMICOLON       reduce using rule 120 (factor -> float_constant .)
    RBRACKET        reduce using rule 120 (factor -> float_constant .)
    LBRACKET        reduce using rule 120 (factor -> float_constant .)
    COMMA           reduce using rule 120 (factor -> float_constant .)
    RPAREN          reduce using rule 120 (factor -> float_constant .)


state 62

    (121) factor -> string_constant .

    MULTIPLY        reduce using rule 121 (factor -> string_constant .)
    DIVIDE          reduce using rule 121 (factor -> string_constant .)
    REM             reduce using rule 121 (factor -> string_constant .)
    PLUS            reduce using rule 121 (factor -> string_constant .)
    MINUS           reduce using rule 121 (factor -> string_constant .)
    GT              reduce using rule 121 (factor -> string_constant .)
    LT              reduce using rule 121 (factor -> string_constant .)
    GE              reduce using rule 121 (factor -> string_constant .)
    LE              reduce using rule 121 (factor -> string_constant .)
    EQ              reduce using rule 121 (factor -> string_constant .)
    NEQ             reduce using rule 121 (factor -> string_constant .)
    SEMICOLON       reduce using rule 121 (factor -> string_constant .)
    RBRACKET        reduce using rule 121 (factor -> string_constant .)
    LBRACKET        reduce using rule 121 (factor -> string_constant .)
    COMMA           reduce using rule 121 (factor -> string_constant .)
    RPAREN          reduce using rule 121 (factor -> string_constant .)


state 63

    (122) factor -> null_constant .

    MULTIPLY        reduce using rule 122 (factor -> null_constant .)
    DIVIDE          reduce using rule 122 (factor -> null_constant .)
    REM             reduce using rule 122 (factor -> null_constant .)
    PLUS            reduce using rule 122 (factor -> null_constant .)
    MINUS           reduce using rule 122 (factor -> null_constant .)
    GT              reduce using rule 122 (factor -> null_constant .)
    LT              reduce using rule 122 (factor -> null_constant .)
    GE              reduce using rule 122 (factor -> null_constant .)
    LE              reduce using rule 122 (factor -> null_constant .)
    EQ              reduce using rule 122 (factor -> null_constant .)
    NEQ             reduce using rule 122 (factor -> null_constant .)
    SEMICOLON       reduce using rule 122 (factor -> null_constant .)
    RBRACKET        reduce using rule 122 (factor -> null_constant .)
    LBRACKET        reduce using rule 122 (factor -> null_constant .)
    COMMA           reduce using rule 122 (factor -> null_constant .)
    RPAREN          reduce using rule 122 (factor -> null_constant .)


state 64

    (123) factor -> IDENT . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 136
    MULTIPLY        reduce using rule 126 (lvalue1 -> .)
    DIVIDE          reduce using rule 126 (lvalue1 -> .)
    REM             reduce using rule 126 (lvalue1 -> .)
    PLUS            reduce using rule 126 (lvalue1 -> .)
    MINUS           reduce using rule 126 (lvalue1 -> .)
    GT              reduce using rule 126 (lvalue1 -> .)
    LT              reduce using rule 126 (lvalue1 -> .)
    GE              reduce using rule 126 (lvalue1 -> .)
    LE              reduce using rule 126 (lvalue1 -> .)
    EQ              reduce using rule 126 (lvalue1 -> .)
    NEQ             reduce using rule 126 (lvalue1 -> .)
    SEMICOLON       reduce using rule 126 (lvalue1 -> .)
    RBRACKET        reduce using rule 126 (lvalue1 -> .)
    COMMA           reduce using rule 126 (lvalue1 -> .)
    RPAREN          reduce using rule 126 (lvalue1 -> .)

  ! LBRACKET        [ reduce using rule 126 (lvalue1 -> .) ]

    lvalue1                        shift and go to state 135

state 65

    (124) factor -> LPAREN . numexpression RPAREN
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 137
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 66

    (48) readstat -> READ expression .

    SEMICOLON       reduce using rule 48 (readstat -> READ expression .)


state 67

    (49) returnstat -> RETURN returnstat1 .

    SEMICOLON       reduce using rule 49 (returnstat -> RETURN returnstat1 .)


state 68

    (50) returnstat1 -> expression .

    SEMICOLON       reduce using rule 50 (returnstat1 -> expression .)


state 69

    (52) ifstat -> IF LPAREN . expression RPAREN statement ifstat1
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 138
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 70

    (55) forstat -> FOR LPAREN . forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (56) forstat1 -> . IDENT forstat3
    (57) forstat1 -> .

    IDENT           shift and go to state 140
    SEMICOLON       reduce using rule 57 (forstat1 -> .)

    forstat1                       shift and go to state 139

state 71

    (62) whilestat -> WHILE LPAREN . expression RPAREN statement
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 141
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 72

    (7) funcdef -> DEF IDENT . LPAREN paramlist RPAREN LBRACE statelist RBRACE

    LPAREN          shift and go to state 142


state 73

    (19) statement -> INT IDENT statement2 .

    $end            reduce using rule 19 (statement -> INT IDENT statement2 .)
    ELSE            reduce using rule 19 (statement -> INT IDENT statement2 .)
    INT             reduce using rule 19 (statement -> INT IDENT statement2 .)
    FLOAT           reduce using rule 19 (statement -> INT IDENT statement2 .)
    STRING          reduce using rule 19 (statement -> INT IDENT statement2 .)
    IDENT           reduce using rule 19 (statement -> INT IDENT statement2 .)
    PRINT           reduce using rule 19 (statement -> INT IDENT statement2 .)
    READ            reduce using rule 19 (statement -> INT IDENT statement2 .)
    RETURN          reduce using rule 19 (statement -> INT IDENT statement2 .)
    IF              reduce using rule 19 (statement -> INT IDENT statement2 .)
    FOR             reduce using rule 19 (statement -> INT IDENT statement2 .)
    WHILE           reduce using rule 19 (statement -> INT IDENT statement2 .)
    LBRACE          reduce using rule 19 (statement -> INT IDENT statement2 .)
    BREAK           reduce using rule 19 (statement -> INT IDENT statement2 .)
    SEMICOLON       reduce using rule 19 (statement -> INT IDENT statement2 .)
    RBRACE          reduce using rule 19 (statement -> INT IDENT statement2 .)


state 74

    (35) statement2 -> LBRACKET . numexpression RBRACKET lvalue1 SEMICOLON
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 143
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 75

    (36) statement2 -> SEMICOLON .

    $end            reduce using rule 36 (statement2 -> SEMICOLON .)
    ELSE            reduce using rule 36 (statement2 -> SEMICOLON .)
    INT             reduce using rule 36 (statement2 -> SEMICOLON .)
    FLOAT           reduce using rule 36 (statement2 -> SEMICOLON .)
    STRING          reduce using rule 36 (statement2 -> SEMICOLON .)
    IDENT           reduce using rule 36 (statement2 -> SEMICOLON .)
    PRINT           reduce using rule 36 (statement2 -> SEMICOLON .)
    READ            reduce using rule 36 (statement2 -> SEMICOLON .)
    RETURN          reduce using rule 36 (statement2 -> SEMICOLON .)
    IF              reduce using rule 36 (statement2 -> SEMICOLON .)
    FOR             reduce using rule 36 (statement2 -> SEMICOLON .)
    WHILE           reduce using rule 36 (statement2 -> SEMICOLON .)
    LBRACE          reduce using rule 36 (statement2 -> SEMICOLON .)
    BREAK           reduce using rule 36 (statement2 -> SEMICOLON .)
    SEMICOLON       reduce using rule 36 (statement2 -> SEMICOLON .)
    RBRACE          reduce using rule 36 (statement2 -> SEMICOLON .)


state 76

    (32) statement1 -> LBRACKET numexpression . RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON

    RBRACKET        shift and go to state 144


state 77

    (33) statement1 -> ASSIGN atribstat1 . SEMICOLON

    SEMICOLON       shift and go to state 145


state 78

    (37) atribstat1 -> expression .

    SEMICOLON       reduce using rule 37 (atribstat1 -> expression .)
    RPAREN          reduce using rule 37 (atribstat1 -> expression .)


state 79

    (38) atribstat1 -> allocexpression .

    SEMICOLON       reduce using rule 38 (atribstat1 -> allocexpression .)
    RPAREN          reduce using rule 38 (atribstat1 -> allocexpression .)


state 80

    (39) atribstat1 -> funccall .

    SEMICOLON       reduce using rule 39 (atribstat1 -> funccall .)
    RPAREN          reduce using rule 39 (atribstat1 -> funccall .)


state 81

    (96) allocexpression -> NEW . types LBRACKET numexpression RBRACKET lvalue1
    (8) types -> . INT
    (9) types -> . FLOAT
    (10) types -> . STRING

    INT             shift and go to state 147
    FLOAT           shift and go to state 148
    STRING          shift and go to state 149

    types                          shift and go to state 146

state 82

    (40) funccall -> IDENT . LPAREN paramlistcall RPAREN
    (123) factor -> IDENT . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LPAREN          shift and go to state 150
    LBRACKET        shift and go to state 136
    MULTIPLY        reduce using rule 126 (lvalue1 -> .)
    DIVIDE          reduce using rule 126 (lvalue1 -> .)
    REM             reduce using rule 126 (lvalue1 -> .)
    PLUS            reduce using rule 126 (lvalue1 -> .)
    MINUS           reduce using rule 126 (lvalue1 -> .)
    GT              reduce using rule 126 (lvalue1 -> .)
    LT              reduce using rule 126 (lvalue1 -> .)
    GE              reduce using rule 126 (lvalue1 -> .)
    LE              reduce using rule 126 (lvalue1 -> .)
    EQ              reduce using rule 126 (lvalue1 -> .)
    NEQ             reduce using rule 126 (lvalue1 -> .)
    SEMICOLON       reduce using rule 126 (lvalue1 -> .)
    RPAREN          reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 135

state 83

    (34) statement1 -> LPAREN paramlistcall . RPAREN SEMICOLON

    RPAREN          shift and go to state 151


state 84

    (41) paramlistcall -> factor . paramlistcall2
    (45) paramlistcall2 -> . LBRACKET numexpression RBRACKET lvalue1 paramlistcall1
    (46) paramlistcall2 -> . paramlistcall1
    (43) paramlistcall1 -> . COMMA paramlistcall
    (44) paramlistcall1 -> .

    LBRACKET        shift and go to state 153
    COMMA           shift and go to state 155
    RPAREN          reduce using rule 44 (paramlistcall1 -> .)

    paramlistcall2                 shift and go to state 152
    paramlistcall1                 shift and go to state 154

state 85

    (20) statement -> FLOAT IDENT statement2 .

    $end            reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    ELSE            reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    INT             reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    FLOAT           reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    STRING          reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    IDENT           reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    PRINT           reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    READ            reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    RETURN          reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    IF              reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    FOR             reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    WHILE           reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    LBRACE          reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    BREAK           reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    SEMICOLON       reduce using rule 20 (statement -> FLOAT IDENT statement2 .)
    RBRACE          reduce using rule 20 (statement -> FLOAT IDENT statement2 .)


state 86

    (21) statement -> STRING IDENT statement2 .

    $end            reduce using rule 21 (statement -> STRING IDENT statement2 .)
    ELSE            reduce using rule 21 (statement -> STRING IDENT statement2 .)
    INT             reduce using rule 21 (statement -> STRING IDENT statement2 .)
    FLOAT           reduce using rule 21 (statement -> STRING IDENT statement2 .)
    STRING          reduce using rule 21 (statement -> STRING IDENT statement2 .)
    IDENT           reduce using rule 21 (statement -> STRING IDENT statement2 .)
    PRINT           reduce using rule 21 (statement -> STRING IDENT statement2 .)
    READ            reduce using rule 21 (statement -> STRING IDENT statement2 .)
    RETURN          reduce using rule 21 (statement -> STRING IDENT statement2 .)
    IF              reduce using rule 21 (statement -> STRING IDENT statement2 .)
    FOR             reduce using rule 21 (statement -> STRING IDENT statement2 .)
    WHILE           reduce using rule 21 (statement -> STRING IDENT statement2 .)
    LBRACE          reduce using rule 21 (statement -> STRING IDENT statement2 .)
    BREAK           reduce using rule 21 (statement -> STRING IDENT statement2 .)
    SEMICOLON       reduce using rule 21 (statement -> STRING IDENT statement2 .)
    RBRACE          reduce using rule 21 (statement -> STRING IDENT statement2 .)


state 87

    (73) statelist -> LBRACE statelist . RBRACE statelist1

    RBRACE          shift and go to state 156


state 88

    (29) statement -> LBRACE statelist RBRACE .

    $end            reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    ELSE            reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    INT             reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    FLOAT           reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    STRING          reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    IDENT           reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    PRINT           reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    READ            reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    RETURN          reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    IF              reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    FOR             reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    WHILE           reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    LBRACE          reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    BREAK           reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    SEMICOLON       reduce using rule 29 (statement -> LBRACE statelist RBRACE .)
    RBRACE          reduce using rule 29 (statement -> LBRACE statelist RBRACE .)


state 89

    (63) statelist -> INT listdcl . IDENT statelist2

    IDENT           shift and go to state 157


state 90

    (17) listdcl -> LBRACKET . RBRACKET listdcl

    RBRACKET        shift and go to state 158


state 91

    (66) statelist -> IDENT statelist3 .

    RBRACE          reduce using rule 66 (statelist -> IDENT statelist3 .)


state 92

    (76) statelist -> IDENT LPAREN . paramlistcall RPAREN SEMICOLON statelist1
    (41) paramlistcall -> . factor paramlistcall2
    (42) paramlistcall -> .
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    RPAREN          reduce using rule 42 (paramlistcall -> .)
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    paramlistcall                  shift and go to state 159
    factor                         shift and go to state 84

state 93

    (94) statelist3 -> LBRACKET . numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON statelist1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 160
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 94

    (95) statelist3 -> ASSIGN . atribstat1 SEMICOLON statelist1
    (37) atribstat1 -> . expression
    (38) atribstat1 -> . allocexpression
    (39) atribstat1 -> . funccall
    (97) expression -> . numexpression expression1
    (96) allocexpression -> . NEW types LBRACKET numexpression RBRACKET lvalue1
    (40) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 81
    IDENT           shift and go to state 82
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    LPAREN          shift and go to state 65

    atribstat1                     shift and go to state 161
    expression                     shift and go to state 78
    allocexpression                shift and go to state 79
    funccall                       shift and go to state 80
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 95

    (64) statelist -> FLOAT listdcl . IDENT statelist2

    IDENT           shift and go to state 162


state 96

    (65) statelist -> STRING listdcl . IDENT statelist2

    IDENT           shift and go to state 163


state 97

    (67) statelist -> PRINT expression . SEMICOLON statelist1

    SEMICOLON       shift and go to state 164


state 98

    (89) statelist1 -> SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 165

state 99

    (75) statelist -> SEMICOLON statelist1 .

    RBRACE          reduce using rule 75 (statelist -> SEMICOLON statelist1 .)


state 100

    (77) statelist1 -> INT . listdcl IDENT statelist2
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 166

state 101

    (80) statelist1 -> IDENT . statelist3
    (90) statelist1 -> IDENT . LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (94) statelist3 -> . LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON statelist1
    (95) statelist3 -> . ASSIGN atribstat1 SEMICOLON statelist1

    LPAREN          shift and go to state 168
    LBRACKET        shift and go to state 93
    ASSIGN          shift and go to state 94

    statelist3                     shift and go to state 167

state 102

    (78) statelist1 -> FLOAT . listdcl IDENT statelist2
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 169

state 103

    (79) statelist1 -> STRING . listdcl IDENT statelist2
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 170

state 104

    (81) statelist1 -> PRINT . expression SEMICOLON statelist1
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 171
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 105

    (82) statelist1 -> READ . IDENT statelist2

    IDENT           shift and go to state 172


state 106

    (83) statelist1 -> RETURN . returnstat1 SEMICOLON statelist1
    (50) returnstat1 -> . expression
    (51) returnstat1 -> .
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 51 (returnstat1 -> .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    returnstat1                    shift and go to state 173
    expression                     shift and go to state 68
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 107

    (84) statelist1 -> IF . LPAREN expression RPAREN statement ifstat1 statelist1

    LPAREN          shift and go to state 174


state 108

    (85) statelist1 -> FOR . LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    LPAREN          shift and go to state 175


state 109

    (86) statelist1 -> WHILE . LPAREN expression RPAREN statement statelist1

    LPAREN          shift and go to state 176


state 110

    (87) statelist1 -> LBRACE . statelist RBRACE statelist1
    (63) statelist -> . INT listdcl IDENT statelist2
    (64) statelist -> . FLOAT listdcl IDENT statelist2
    (65) statelist -> . STRING listdcl IDENT statelist2
    (66) statelist -> . IDENT statelist3
    (67) statelist -> . PRINT expression SEMICOLON statelist1
    (68) statelist -> . READ IDENT statelist2
    (69) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (70) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (71) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (72) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (73) statelist -> . LBRACE statelist RBRACE statelist1
    (74) statelist -> . BREAK SEMICOLON statelist1
    (75) statelist -> . SEMICOLON statelist1
    (76) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 37
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 38
    PRINT           shift and go to state 41
    READ            shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    FOR             shift and go to state 46
    WHILE           shift and go to state 47
    LBRACE          shift and go to state 35
    BREAK           shift and go to state 48
    SEMICOLON       shift and go to state 42

    statelist                      shift and go to state 177

state 111

    (88) statelist1 -> BREAK . SEMICOLON statelist1

    SEMICOLON       shift and go to state 178


state 112

    (68) statelist -> READ IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 179

state 113

    (69) statelist -> RETURN returnstat1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 182


state 114

    (70) statelist -> IF LPAREN . expression RPAREN statement ifstat1 statelist1
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 183
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 115

    (71) statelist -> FOR LPAREN . forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (56) forstat1 -> . IDENT forstat3
    (57) forstat1 -> .

    IDENT           shift and go to state 140
    SEMICOLON       reduce using rule 57 (forstat1 -> .)

    forstat1                       shift and go to state 184

state 116

    (72) statelist -> WHILE LPAREN . expression RPAREN statement statelist1
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 185
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 117

    (74) statelist -> BREAK SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 186

state 118

    (5) funclist1 -> DEF IDENT . LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1

    LPAREN          shift and go to state 187


state 119

    (97) expression -> numexpression expression1 .

    SEMICOLON       reduce using rule 97 (expression -> numexpression expression1 .)
    RPAREN          reduce using rule 97 (expression -> numexpression expression1 .)


state 120

    (98) expression1 -> compoperator . numexpression
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 188
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 121

    (100) compoperator -> GT .

    PLUS            reduce using rule 100 (compoperator -> GT .)
    MINUS           reduce using rule 100 (compoperator -> GT .)
    int_constant    reduce using rule 100 (compoperator -> GT .)
    float_constant  reduce using rule 100 (compoperator -> GT .)
    string_constant reduce using rule 100 (compoperator -> GT .)
    null_constant   reduce using rule 100 (compoperator -> GT .)
    IDENT           reduce using rule 100 (compoperator -> GT .)
    LPAREN          reduce using rule 100 (compoperator -> GT .)


state 122

    (101) compoperator -> LT .

    PLUS            reduce using rule 101 (compoperator -> LT .)
    MINUS           reduce using rule 101 (compoperator -> LT .)
    int_constant    reduce using rule 101 (compoperator -> LT .)
    float_constant  reduce using rule 101 (compoperator -> LT .)
    string_constant reduce using rule 101 (compoperator -> LT .)
    null_constant   reduce using rule 101 (compoperator -> LT .)
    IDENT           reduce using rule 101 (compoperator -> LT .)
    LPAREN          reduce using rule 101 (compoperator -> LT .)


state 123

    (102) compoperator -> GE .

    PLUS            reduce using rule 102 (compoperator -> GE .)
    MINUS           reduce using rule 102 (compoperator -> GE .)
    int_constant    reduce using rule 102 (compoperator -> GE .)
    float_constant  reduce using rule 102 (compoperator -> GE .)
    string_constant reduce using rule 102 (compoperator -> GE .)
    null_constant   reduce using rule 102 (compoperator -> GE .)
    IDENT           reduce using rule 102 (compoperator -> GE .)
    LPAREN          reduce using rule 102 (compoperator -> GE .)


state 124

    (103) compoperator -> LE .

    PLUS            reduce using rule 103 (compoperator -> LE .)
    MINUS           reduce using rule 103 (compoperator -> LE .)
    int_constant    reduce using rule 103 (compoperator -> LE .)
    float_constant  reduce using rule 103 (compoperator -> LE .)
    string_constant reduce using rule 103 (compoperator -> LE .)
    null_constant   reduce using rule 103 (compoperator -> LE .)
    IDENT           reduce using rule 103 (compoperator -> LE .)
    LPAREN          reduce using rule 103 (compoperator -> LE .)


state 125

    (104) compoperator -> EQ .

    PLUS            reduce using rule 104 (compoperator -> EQ .)
    MINUS           reduce using rule 104 (compoperator -> EQ .)
    int_constant    reduce using rule 104 (compoperator -> EQ .)
    float_constant  reduce using rule 104 (compoperator -> EQ .)
    string_constant reduce using rule 104 (compoperator -> EQ .)
    null_constant   reduce using rule 104 (compoperator -> EQ .)
    IDENT           reduce using rule 104 (compoperator -> EQ .)
    LPAREN          reduce using rule 104 (compoperator -> EQ .)


state 126

    (105) compoperator -> NEQ .

    PLUS            reduce using rule 105 (compoperator -> NEQ .)
    MINUS           reduce using rule 105 (compoperator -> NEQ .)
    int_constant    reduce using rule 105 (compoperator -> NEQ .)
    float_constant  reduce using rule 105 (compoperator -> NEQ .)
    string_constant reduce using rule 105 (compoperator -> NEQ .)
    null_constant   reduce using rule 105 (compoperator -> NEQ .)
    IDENT           reduce using rule 105 (compoperator -> NEQ .)
    LPAREN          reduce using rule 105 (compoperator -> NEQ .)


state 127

    (106) numexpression -> term numexpression1 .

    GT              reduce using rule 106 (numexpression -> term numexpression1 .)
    LT              reduce using rule 106 (numexpression -> term numexpression1 .)
    GE              reduce using rule 106 (numexpression -> term numexpression1 .)
    LE              reduce using rule 106 (numexpression -> term numexpression1 .)
    EQ              reduce using rule 106 (numexpression -> term numexpression1 .)
    NEQ             reduce using rule 106 (numexpression -> term numexpression1 .)
    SEMICOLON       reduce using rule 106 (numexpression -> term numexpression1 .)
    RBRACKET        reduce using rule 106 (numexpression -> term numexpression1 .)
    RPAREN          reduce using rule 106 (numexpression -> term numexpression1 .)


state 128

    (107) numexpression1 -> addsub . term
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    addsub                         shift and go to state 56
    term                           shift and go to state 189
    unaryexpr                      shift and go to state 55
    factor                         shift and go to state 57

state 129

    (111) term -> unaryexpr term1 .

    PLUS            reduce using rule 111 (term -> unaryexpr term1 .)
    MINUS           reduce using rule 111 (term -> unaryexpr term1 .)
    GT              reduce using rule 111 (term -> unaryexpr term1 .)
    LT              reduce using rule 111 (term -> unaryexpr term1 .)
    GE              reduce using rule 111 (term -> unaryexpr term1 .)
    LE              reduce using rule 111 (term -> unaryexpr term1 .)
    EQ              reduce using rule 111 (term -> unaryexpr term1 .)
    NEQ             reduce using rule 111 (term -> unaryexpr term1 .)
    SEMICOLON       reduce using rule 111 (term -> unaryexpr term1 .)
    RBRACKET        reduce using rule 111 (term -> unaryexpr term1 .)
    RPAREN          reduce using rule 111 (term -> unaryexpr term1 .)


state 130

    (112) term1 -> multdiv . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    unaryexpr                      shift and go to state 190
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 131

    (114) multdiv -> MULTIPLY .

    PLUS            reduce using rule 114 (multdiv -> MULTIPLY .)
    MINUS           reduce using rule 114 (multdiv -> MULTIPLY .)
    int_constant    reduce using rule 114 (multdiv -> MULTIPLY .)
    float_constant  reduce using rule 114 (multdiv -> MULTIPLY .)
    string_constant reduce using rule 114 (multdiv -> MULTIPLY .)
    null_constant   reduce using rule 114 (multdiv -> MULTIPLY .)
    IDENT           reduce using rule 114 (multdiv -> MULTIPLY .)
    LPAREN          reduce using rule 114 (multdiv -> MULTIPLY .)


state 132

    (115) multdiv -> DIVIDE .

    PLUS            reduce using rule 115 (multdiv -> DIVIDE .)
    MINUS           reduce using rule 115 (multdiv -> DIVIDE .)
    int_constant    reduce using rule 115 (multdiv -> DIVIDE .)
    float_constant  reduce using rule 115 (multdiv -> DIVIDE .)
    string_constant reduce using rule 115 (multdiv -> DIVIDE .)
    null_constant   reduce using rule 115 (multdiv -> DIVIDE .)
    IDENT           reduce using rule 115 (multdiv -> DIVIDE .)
    LPAREN          reduce using rule 115 (multdiv -> DIVIDE .)


state 133

    (116) multdiv -> REM .

    PLUS            reduce using rule 116 (multdiv -> REM .)
    MINUS           reduce using rule 116 (multdiv -> REM .)
    int_constant    reduce using rule 116 (multdiv -> REM .)
    float_constant  reduce using rule 116 (multdiv -> REM .)
    string_constant reduce using rule 116 (multdiv -> REM .)
    null_constant   reduce using rule 116 (multdiv -> REM .)
    IDENT           reduce using rule 116 (multdiv -> REM .)
    LPAREN          reduce using rule 116 (multdiv -> REM .)


state 134

    (117) unaryexpr -> addsub factor .

    MULTIPLY        reduce using rule 117 (unaryexpr -> addsub factor .)
    DIVIDE          reduce using rule 117 (unaryexpr -> addsub factor .)
    REM             reduce using rule 117 (unaryexpr -> addsub factor .)
    PLUS            reduce using rule 117 (unaryexpr -> addsub factor .)
    MINUS           reduce using rule 117 (unaryexpr -> addsub factor .)
    GT              reduce using rule 117 (unaryexpr -> addsub factor .)
    LT              reduce using rule 117 (unaryexpr -> addsub factor .)
    GE              reduce using rule 117 (unaryexpr -> addsub factor .)
    LE              reduce using rule 117 (unaryexpr -> addsub factor .)
    EQ              reduce using rule 117 (unaryexpr -> addsub factor .)
    NEQ             reduce using rule 117 (unaryexpr -> addsub factor .)
    SEMICOLON       reduce using rule 117 (unaryexpr -> addsub factor .)
    RBRACKET        reduce using rule 117 (unaryexpr -> addsub factor .)
    RPAREN          reduce using rule 117 (unaryexpr -> addsub factor .)


state 135

    (123) factor -> IDENT lvalue1 .

    MULTIPLY        reduce using rule 123 (factor -> IDENT lvalue1 .)
    DIVIDE          reduce using rule 123 (factor -> IDENT lvalue1 .)
    REM             reduce using rule 123 (factor -> IDENT lvalue1 .)
    PLUS            reduce using rule 123 (factor -> IDENT lvalue1 .)
    MINUS           reduce using rule 123 (factor -> IDENT lvalue1 .)
    GT              reduce using rule 123 (factor -> IDENT lvalue1 .)
    LT              reduce using rule 123 (factor -> IDENT lvalue1 .)
    GE              reduce using rule 123 (factor -> IDENT lvalue1 .)
    LE              reduce using rule 123 (factor -> IDENT lvalue1 .)
    EQ              reduce using rule 123 (factor -> IDENT lvalue1 .)
    NEQ             reduce using rule 123 (factor -> IDENT lvalue1 .)
    SEMICOLON       reduce using rule 123 (factor -> IDENT lvalue1 .)
    RBRACKET        reduce using rule 123 (factor -> IDENT lvalue1 .)
    LBRACKET        reduce using rule 123 (factor -> IDENT lvalue1 .)
    COMMA           reduce using rule 123 (factor -> IDENT lvalue1 .)
    RPAREN          reduce using rule 123 (factor -> IDENT lvalue1 .)


state 136

    (125) lvalue1 -> LBRACKET . numexpression RBRACKET lvalue1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 191
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 137

    (124) factor -> LPAREN numexpression . RPAREN

    RPAREN          shift and go to state 192


state 138

    (52) ifstat -> IF LPAREN expression . RPAREN statement ifstat1

    RPAREN          shift and go to state 193


state 139

    (55) forstat -> FOR LPAREN forstat1 . SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement

    SEMICOLON       shift and go to state 194


state 140

    (56) forstat1 -> IDENT . forstat3
    (60) forstat3 -> . LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1
    (61) forstat3 -> . ASSIGN atribstat1

    LBRACKET        shift and go to state 196
    ASSIGN          shift and go to state 197

    forstat3                       shift and go to state 195

state 141

    (62) whilestat -> WHILE LPAREN expression . RPAREN statement

    RPAREN          shift and go to state 198


state 142

    (7) funcdef -> DEF IDENT LPAREN . paramlist RPAREN LBRACE statelist RBRACE
    (11) paramlist -> . STRING listdcl IDENT paramlist1
    (12) paramlist -> . FLOAT listdcl IDENT paramlist1
    (13) paramlist -> . INT listdcl IDENT paramlist1
    (14) paramlist -> .

    STRING          shift and go to state 200
    FLOAT           shift and go to state 201
    INT             shift and go to state 202
    RPAREN          reduce using rule 14 (paramlist -> .)

    paramlist                      shift and go to state 199

state 143

    (35) statement2 -> LBRACKET numexpression . RBRACKET lvalue1 SEMICOLON

    RBRACKET        shift and go to state 203


state 144

    (32) statement1 -> LBRACKET numexpression RBRACKET . lvalue1 ASSIGN atribstat1 SEMICOLON
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LBRACKET        shift and go to state 136
    ASSIGN          reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 204

state 145

    (33) statement1 -> ASSIGN atribstat1 SEMICOLON .

    $end            reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    ELSE            reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    INT             reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    FLOAT           reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    STRING          reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    IDENT           reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    PRINT           reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    READ            reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    RETURN          reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    IF              reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    FOR             reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    WHILE           reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    LBRACE          reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    BREAK           reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    SEMICOLON       reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)
    RBRACE          reduce using rule 33 (statement1 -> ASSIGN atribstat1 SEMICOLON .)


state 146

    (96) allocexpression -> NEW types . LBRACKET numexpression RBRACKET lvalue1

    LBRACKET        shift and go to state 205


state 147

    (8) types -> INT .

    LBRACKET        reduce using rule 8 (types -> INT .)


state 148

    (9) types -> FLOAT .

    LBRACKET        reduce using rule 9 (types -> FLOAT .)


state 149

    (10) types -> STRING .

    LBRACKET        reduce using rule 10 (types -> STRING .)


state 150

    (40) funccall -> IDENT LPAREN . paramlistcall RPAREN
    (41) paramlistcall -> . factor paramlistcall2
    (42) paramlistcall -> .
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    RPAREN          reduce using rule 42 (paramlistcall -> .)
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    paramlistcall                  shift and go to state 206
    factor                         shift and go to state 84

state 151

    (34) statement1 -> LPAREN paramlistcall RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 207


state 152

    (41) paramlistcall -> factor paramlistcall2 .

    RPAREN          reduce using rule 41 (paramlistcall -> factor paramlistcall2 .)


state 153

    (45) paramlistcall2 -> LBRACKET . numexpression RBRACKET lvalue1 paramlistcall1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 208
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 154

    (46) paramlistcall2 -> paramlistcall1 .

    RPAREN          reduce using rule 46 (paramlistcall2 -> paramlistcall1 .)


state 155

    (43) paramlistcall1 -> COMMA . paramlistcall
    (41) paramlistcall -> . factor paramlistcall2
    (42) paramlistcall -> .
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    RPAREN          reduce using rule 42 (paramlistcall -> .)
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    paramlistcall                  shift and go to state 209
    factor                         shift and go to state 84

state 156

    (73) statelist -> LBRACE statelist RBRACE . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 210

state 157

    (63) statelist -> INT listdcl IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 211

state 158

    (17) listdcl -> LBRACKET RBRACKET . listdcl
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 212

state 159

    (76) statelist -> IDENT LPAREN paramlistcall . RPAREN SEMICOLON statelist1

    RPAREN          shift and go to state 213


state 160

    (94) statelist3 -> LBRACKET numexpression . RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON statelist1

    RBRACKET        shift and go to state 214


state 161

    (95) statelist3 -> ASSIGN atribstat1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 215


state 162

    (64) statelist -> FLOAT listdcl IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 216

state 163

    (65) statelist -> STRING listdcl IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 217

state 164

    (67) statelist -> PRINT expression SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 218

state 165

    (89) statelist1 -> SEMICOLON statelist1 .

    RBRACE          reduce using rule 89 (statelist1 -> SEMICOLON statelist1 .)


state 166

    (77) statelist1 -> INT listdcl . IDENT statelist2

    IDENT           shift and go to state 219


state 167

    (80) statelist1 -> IDENT statelist3 .

    RBRACE          reduce using rule 80 (statelist1 -> IDENT statelist3 .)


state 168

    (90) statelist1 -> IDENT LPAREN . paramlistcall RPAREN SEMICOLON statelist1
    (41) paramlistcall -> . factor paramlistcall2
    (42) paramlistcall -> .
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    RPAREN          reduce using rule 42 (paramlistcall -> .)
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    paramlistcall                  shift and go to state 220
    factor                         shift and go to state 84

state 169

    (78) statelist1 -> FLOAT listdcl . IDENT statelist2

    IDENT           shift and go to state 221


state 170

    (79) statelist1 -> STRING listdcl . IDENT statelist2

    IDENT           shift and go to state 222


state 171

    (81) statelist1 -> PRINT expression . SEMICOLON statelist1

    SEMICOLON       shift and go to state 223


state 172

    (82) statelist1 -> READ IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 224

state 173

    (83) statelist1 -> RETURN returnstat1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 225


state 174

    (84) statelist1 -> IF LPAREN . expression RPAREN statement ifstat1 statelist1
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 226
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 175

    (85) statelist1 -> FOR LPAREN . forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (56) forstat1 -> . IDENT forstat3
    (57) forstat1 -> .

    IDENT           shift and go to state 140
    SEMICOLON       reduce using rule 57 (forstat1 -> .)

    forstat1                       shift and go to state 227

state 176

    (86) statelist1 -> WHILE LPAREN . expression RPAREN statement statelist1
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    expression                     shift and go to state 228
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 177

    (87) statelist1 -> LBRACE statelist . RBRACE statelist1

    RBRACE          shift and go to state 229


state 178

    (88) statelist1 -> BREAK SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 230

state 179

    (68) statelist -> READ IDENT statelist2 .

    RBRACE          reduce using rule 68 (statelist -> READ IDENT statelist2 .)


state 180

    (92) statelist2 -> LBRACKET . numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 231
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 181

    (93) statelist2 -> SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 232

state 182

    (69) statelist -> RETURN returnstat1 SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 233

state 183

    (70) statelist -> IF LPAREN expression . RPAREN statement ifstat1 statelist1

    RPAREN          shift and go to state 234


state 184

    (71) statelist -> FOR LPAREN forstat1 . SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 235


state 185

    (72) statelist -> WHILE LPAREN expression . RPAREN statement statelist1

    RPAREN          shift and go to state 236


state 186

    (74) statelist -> BREAK SEMICOLON statelist1 .

    RBRACE          reduce using rule 74 (statelist -> BREAK SEMICOLON statelist1 .)


state 187

    (5) funclist1 -> DEF IDENT LPAREN . paramlist RPAREN LBRACE statelist RBRACE funclist1
    (11) paramlist -> . STRING listdcl IDENT paramlist1
    (12) paramlist -> . FLOAT listdcl IDENT paramlist1
    (13) paramlist -> . INT listdcl IDENT paramlist1
    (14) paramlist -> .

    STRING          shift and go to state 200
    FLOAT           shift and go to state 201
    INT             shift and go to state 202
    RPAREN          reduce using rule 14 (paramlist -> .)

    paramlist                      shift and go to state 237

state 188

    (98) expression1 -> compoperator numexpression .

    SEMICOLON       reduce using rule 98 (expression1 -> compoperator numexpression .)
    RPAREN          reduce using rule 98 (expression1 -> compoperator numexpression .)


state 189

    (107) numexpression1 -> addsub term .

    GT              reduce using rule 107 (numexpression1 -> addsub term .)
    LT              reduce using rule 107 (numexpression1 -> addsub term .)
    GE              reduce using rule 107 (numexpression1 -> addsub term .)
    LE              reduce using rule 107 (numexpression1 -> addsub term .)
    EQ              reduce using rule 107 (numexpression1 -> addsub term .)
    NEQ             reduce using rule 107 (numexpression1 -> addsub term .)
    SEMICOLON       reduce using rule 107 (numexpression1 -> addsub term .)
    RBRACKET        reduce using rule 107 (numexpression1 -> addsub term .)
    RPAREN          reduce using rule 107 (numexpression1 -> addsub term .)


state 190

    (112) term1 -> multdiv unaryexpr . term1
    (112) term1 -> . multdiv unaryexpr term1
    (113) term1 -> .
    (114) multdiv -> . MULTIPLY
    (115) multdiv -> . DIVIDE
    (116) multdiv -> . REM

    PLUS            reduce using rule 113 (term1 -> .)
    MINUS           reduce using rule 113 (term1 -> .)
    GT              reduce using rule 113 (term1 -> .)
    LT              reduce using rule 113 (term1 -> .)
    GE              reduce using rule 113 (term1 -> .)
    LE              reduce using rule 113 (term1 -> .)
    EQ              reduce using rule 113 (term1 -> .)
    NEQ             reduce using rule 113 (term1 -> .)
    SEMICOLON       reduce using rule 113 (term1 -> .)
    RBRACKET        reduce using rule 113 (term1 -> .)
    RPAREN          reduce using rule 113 (term1 -> .)
    MULTIPLY        shift and go to state 131
    DIVIDE          shift and go to state 132
    REM             shift and go to state 133

    multdiv                        shift and go to state 130
    term1                          shift and go to state 238

state 191

    (125) lvalue1 -> LBRACKET numexpression . RBRACKET lvalue1

    RBRACKET        shift and go to state 239


state 192

    (124) factor -> LPAREN numexpression RPAREN .

    MULTIPLY        reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    DIVIDE          reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    REM             reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    PLUS            reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    MINUS           reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    GT              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    LT              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    GE              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    LE              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    EQ              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    NEQ             reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    SEMICOLON       reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    RBRACKET        reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    LBRACKET        reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    COMMA           reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    RPAREN          reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)


state 193

    (52) ifstat -> IF LPAREN expression RPAREN . statement ifstat1
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 240
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 194

    (55) forstat -> FOR LPAREN forstat1 SEMICOLON . forstat2 SEMICOLON forstat1 RPAREN statement
    (58) forstat2 -> . expression
    (59) forstat2 -> .
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 59 (forstat2 -> .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    forstat2                       shift and go to state 241
    expression                     shift and go to state 242
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 195

    (56) forstat1 -> IDENT forstat3 .

    SEMICOLON       reduce using rule 56 (forstat1 -> IDENT forstat3 .)
    RPAREN          reduce using rule 56 (forstat1 -> IDENT forstat3 .)


state 196

    (60) forstat3 -> LBRACKET . numexpression RBRACKET lvalue1 ASSIGN atribstat1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 243
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 197

    (61) forstat3 -> ASSIGN . atribstat1
    (37) atribstat1 -> . expression
    (38) atribstat1 -> . allocexpression
    (39) atribstat1 -> . funccall
    (97) expression -> . numexpression expression1
    (96) allocexpression -> . NEW types LBRACKET numexpression RBRACKET lvalue1
    (40) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 81
    IDENT           shift and go to state 82
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    LPAREN          shift and go to state 65

    atribstat1                     shift and go to state 244
    expression                     shift and go to state 78
    allocexpression                shift and go to state 79
    funccall                       shift and go to state 80
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 198

    (62) whilestat -> WHILE LPAREN expression RPAREN . statement
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 245
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 199

    (7) funcdef -> DEF IDENT LPAREN paramlist . RPAREN LBRACE statelist RBRACE

    RPAREN          shift and go to state 246


state 200

    (11) paramlist -> STRING . listdcl IDENT paramlist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 247

state 201

    (12) paramlist -> FLOAT . listdcl IDENT paramlist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 248

state 202

    (13) paramlist -> INT . listdcl IDENT paramlist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> .

    LBRACKET        shift and go to state 90
    IDENT           reduce using rule 18 (listdcl -> .)

    listdcl                        shift and go to state 249

state 203

    (35) statement2 -> LBRACKET numexpression RBRACKET . lvalue1 SEMICOLON
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LBRACKET        shift and go to state 136
    SEMICOLON       reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 250

state 204

    (32) statement1 -> LBRACKET numexpression RBRACKET lvalue1 . ASSIGN atribstat1 SEMICOLON

    ASSIGN          shift and go to state 251


state 205

    (96) allocexpression -> NEW types LBRACKET . numexpression RBRACKET lvalue1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 252
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 206

    (40) funccall -> IDENT LPAREN paramlistcall . RPAREN

    RPAREN          shift and go to state 253


state 207

    (34) statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .

    $end            reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    ELSE            reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    INT             reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    FLOAT           reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    STRING          reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    IDENT           reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    PRINT           reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    READ            reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    RETURN          reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    IF              reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    FOR             reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    WHILE           reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    LBRACE          reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    BREAK           reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)
    RBRACE          reduce using rule 34 (statement1 -> LPAREN paramlistcall RPAREN SEMICOLON .)


state 208

    (45) paramlistcall2 -> LBRACKET numexpression . RBRACKET lvalue1 paramlistcall1

    RBRACKET        shift and go to state 254


state 209

    (43) paramlistcall1 -> COMMA paramlistcall .

    RPAREN          reduce using rule 43 (paramlistcall1 -> COMMA paramlistcall .)


state 210

    (73) statelist -> LBRACE statelist RBRACE statelist1 .

    RBRACE          reduce using rule 73 (statelist -> LBRACE statelist RBRACE statelist1 .)


state 211

    (63) statelist -> INT listdcl IDENT statelist2 .

    RBRACE          reduce using rule 63 (statelist -> INT listdcl IDENT statelist2 .)


state 212

    (17) listdcl -> LBRACKET RBRACKET listdcl .

    IDENT           reduce using rule 17 (listdcl -> LBRACKET RBRACKET listdcl .)


state 213

    (76) statelist -> IDENT LPAREN paramlistcall RPAREN . SEMICOLON statelist1

    SEMICOLON       shift and go to state 255


state 214

    (94) statelist3 -> LBRACKET numexpression RBRACKET . lvalue1 ASSIGN atribstat1 SEMICOLON statelist1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LBRACKET        shift and go to state 136
    ASSIGN          reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 256

state 215

    (95) statelist3 -> ASSIGN atribstat1 SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 257

state 216

    (64) statelist -> FLOAT listdcl IDENT statelist2 .

    RBRACE          reduce using rule 64 (statelist -> FLOAT listdcl IDENT statelist2 .)


state 217

    (65) statelist -> STRING listdcl IDENT statelist2 .

    RBRACE          reduce using rule 65 (statelist -> STRING listdcl IDENT statelist2 .)


state 218

    (67) statelist -> PRINT expression SEMICOLON statelist1 .

    RBRACE          reduce using rule 67 (statelist -> PRINT expression SEMICOLON statelist1 .)


state 219

    (77) statelist1 -> INT listdcl IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 258

state 220

    (90) statelist1 -> IDENT LPAREN paramlistcall . RPAREN SEMICOLON statelist1

    RPAREN          shift and go to state 259


state 221

    (78) statelist1 -> FLOAT listdcl IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 260

state 222

    (79) statelist1 -> STRING listdcl IDENT . statelist2
    (92) statelist2 -> . LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1
    (93) statelist2 -> . SEMICOLON statelist1

    LBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 181

    statelist2                     shift and go to state 261

state 223

    (81) statelist1 -> PRINT expression SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 262

state 224

    (82) statelist1 -> READ IDENT statelist2 .

    RBRACE          reduce using rule 82 (statelist1 -> READ IDENT statelist2 .)


state 225

    (83) statelist1 -> RETURN returnstat1 SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 263

state 226

    (84) statelist1 -> IF LPAREN expression . RPAREN statement ifstat1 statelist1

    RPAREN          shift and go to state 264


state 227

    (85) statelist1 -> FOR LPAREN forstat1 . SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 265


state 228

    (86) statelist1 -> WHILE LPAREN expression . RPAREN statement statelist1

    RPAREN          shift and go to state 266


state 229

    (87) statelist1 -> LBRACE statelist RBRACE . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 267

state 230

    (88) statelist1 -> BREAK SEMICOLON statelist1 .

    RBRACE          reduce using rule 88 (statelist1 -> BREAK SEMICOLON statelist1 .)


state 231

    (92) statelist2 -> LBRACKET numexpression . RBRACKET lvalue1 SEMICOLON statelist1

    RBRACKET        shift and go to state 268


state 232

    (93) statelist2 -> SEMICOLON statelist1 .

    RBRACE          reduce using rule 93 (statelist2 -> SEMICOLON statelist1 .)


state 233

    (69) statelist -> RETURN returnstat1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 69 (statelist -> RETURN returnstat1 SEMICOLON statelist1 .)


state 234

    (70) statelist -> IF LPAREN expression RPAREN . statement ifstat1 statelist1
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 269
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 235

    (71) statelist -> FOR LPAREN forstat1 SEMICOLON . forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (58) forstat2 -> . expression
    (59) forstat2 -> .
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 59 (forstat2 -> .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    forstat2                       shift and go to state 270
    expression                     shift and go to state 242
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 236

    (72) statelist -> WHILE LPAREN expression RPAREN . statement statelist1
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 271
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 237

    (5) funclist1 -> DEF IDENT LPAREN paramlist . RPAREN LBRACE statelist RBRACE funclist1

    RPAREN          shift and go to state 272


state 238

    (112) term1 -> multdiv unaryexpr term1 .

    PLUS            reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    MINUS           reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    GT              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    LT              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    GE              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    LE              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    EQ              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    NEQ             reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    SEMICOLON       reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    RBRACKET        reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    RPAREN          reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)


state 239

    (125) lvalue1 -> LBRACKET numexpression RBRACKET . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 136
    MULTIPLY        reduce using rule 126 (lvalue1 -> .)
    DIVIDE          reduce using rule 126 (lvalue1 -> .)
    REM             reduce using rule 126 (lvalue1 -> .)
    PLUS            reduce using rule 126 (lvalue1 -> .)
    MINUS           reduce using rule 126 (lvalue1 -> .)
    GT              reduce using rule 126 (lvalue1 -> .)
    LT              reduce using rule 126 (lvalue1 -> .)
    GE              reduce using rule 126 (lvalue1 -> .)
    LE              reduce using rule 126 (lvalue1 -> .)
    EQ              reduce using rule 126 (lvalue1 -> .)
    NEQ             reduce using rule 126 (lvalue1 -> .)
    SEMICOLON       reduce using rule 126 (lvalue1 -> .)
    RBRACKET        reduce using rule 126 (lvalue1 -> .)
    COMMA           reduce using rule 126 (lvalue1 -> .)
    RPAREN          reduce using rule 126 (lvalue1 -> .)
    ASSIGN          reduce using rule 126 (lvalue1 -> .)

  ! LBRACKET        [ reduce using rule 126 (lvalue1 -> .) ]

    lvalue1                        shift and go to state 273

state 240

    (52) ifstat -> IF LPAREN expression RPAREN statement . ifstat1
    (53) ifstat1 -> . ELSE statement
    (54) ifstat1 -> .

    ELSE            shift and go to state 275
    $end            reduce using rule 54 (ifstat1 -> .)
    INT             reduce using rule 54 (ifstat1 -> .)
    FLOAT           reduce using rule 54 (ifstat1 -> .)
    STRING          reduce using rule 54 (ifstat1 -> .)
    IDENT           reduce using rule 54 (ifstat1 -> .)
    PRINT           reduce using rule 54 (ifstat1 -> .)
    READ            reduce using rule 54 (ifstat1 -> .)
    RETURN          reduce using rule 54 (ifstat1 -> .)
    IF              reduce using rule 54 (ifstat1 -> .)
    FOR             reduce using rule 54 (ifstat1 -> .)
    WHILE           reduce using rule 54 (ifstat1 -> .)
    LBRACE          reduce using rule 54 (ifstat1 -> .)
    BREAK           reduce using rule 54 (ifstat1 -> .)
    SEMICOLON       reduce using rule 54 (ifstat1 -> .)
    RBRACE          reduce using rule 54 (ifstat1 -> .)

  ! ELSE            [ reduce using rule 54 (ifstat1 -> .) ]

    ifstat1                        shift and go to state 274

state 241

    (55) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 . SEMICOLON forstat1 RPAREN statement

    SEMICOLON       shift and go to state 276


state 242

    (58) forstat2 -> expression .

    SEMICOLON       reduce using rule 58 (forstat2 -> expression .)


state 243

    (60) forstat3 -> LBRACKET numexpression . RBRACKET lvalue1 ASSIGN atribstat1

    RBRACKET        shift and go to state 277


state 244

    (61) forstat3 -> ASSIGN atribstat1 .

    SEMICOLON       reduce using rule 61 (forstat3 -> ASSIGN atribstat1 .)
    RPAREN          reduce using rule 61 (forstat3 -> ASSIGN atribstat1 .)


state 245

    (62) whilestat -> WHILE LPAREN expression RPAREN statement .

    $end            reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    STRING          reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    IDENT           reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    PRINT           reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    READ            reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    SEMICOLON       reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    RBRACE          reduce using rule 62 (whilestat -> WHILE LPAREN expression RPAREN statement .)


state 246

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN . LBRACE statelist RBRACE

    LBRACE          shift and go to state 278


state 247

    (11) paramlist -> STRING listdcl . IDENT paramlist1

    IDENT           shift and go to state 279


state 248

    (12) paramlist -> FLOAT listdcl . IDENT paramlist1

    IDENT           shift and go to state 280


state 249

    (13) paramlist -> INT listdcl . IDENT paramlist1

    IDENT           shift and go to state 281


state 250

    (35) statement2 -> LBRACKET numexpression RBRACKET lvalue1 . SEMICOLON

    SEMICOLON       shift and go to state 282


state 251

    (32) statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN . atribstat1 SEMICOLON
    (37) atribstat1 -> . expression
    (38) atribstat1 -> . allocexpression
    (39) atribstat1 -> . funccall
    (97) expression -> . numexpression expression1
    (96) allocexpression -> . NEW types LBRACKET numexpression RBRACKET lvalue1
    (40) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 81
    IDENT           shift and go to state 82
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 53
    atribstat1                     shift and go to state 283
    expression                     shift and go to state 78
    allocexpression                shift and go to state 79
    funccall                       shift and go to state 80
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 252

    (96) allocexpression -> NEW types LBRACKET numexpression . RBRACKET lvalue1

    RBRACKET        shift and go to state 284


state 253

    (40) funccall -> IDENT LPAREN paramlistcall RPAREN .

    SEMICOLON       reduce using rule 40 (funccall -> IDENT LPAREN paramlistcall RPAREN .)
    RPAREN          reduce using rule 40 (funccall -> IDENT LPAREN paramlistcall RPAREN .)


state 254

    (45) paramlistcall2 -> LBRACKET numexpression RBRACKET . lvalue1 paramlistcall1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LBRACKET        shift and go to state 136
    COMMA           reduce using rule 126 (lvalue1 -> .)
    RPAREN          reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 285

state 255

    (76) statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 286

state 256

    (94) statelist3 -> LBRACKET numexpression RBRACKET lvalue1 . ASSIGN atribstat1 SEMICOLON statelist1

    ASSIGN          shift and go to state 287


state 257

    (95) statelist3 -> ASSIGN atribstat1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 95 (statelist3 -> ASSIGN atribstat1 SEMICOLON statelist1 .)


state 258

    (77) statelist1 -> INT listdcl IDENT statelist2 .

    RBRACE          reduce using rule 77 (statelist1 -> INT listdcl IDENT statelist2 .)


state 259

    (90) statelist1 -> IDENT LPAREN paramlistcall RPAREN . SEMICOLON statelist1

    SEMICOLON       shift and go to state 288


state 260

    (78) statelist1 -> FLOAT listdcl IDENT statelist2 .

    RBRACE          reduce using rule 78 (statelist1 -> FLOAT listdcl IDENT statelist2 .)


state 261

    (79) statelist1 -> STRING listdcl IDENT statelist2 .

    RBRACE          reduce using rule 79 (statelist1 -> STRING listdcl IDENT statelist2 .)


state 262

    (81) statelist1 -> PRINT expression SEMICOLON statelist1 .

    RBRACE          reduce using rule 81 (statelist1 -> PRINT expression SEMICOLON statelist1 .)


state 263

    (83) statelist1 -> RETURN returnstat1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 83 (statelist1 -> RETURN returnstat1 SEMICOLON statelist1 .)


state 264

    (84) statelist1 -> IF LPAREN expression RPAREN . statement ifstat1 statelist1
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 289
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 265

    (85) statelist1 -> FOR LPAREN forstat1 SEMICOLON . forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (58) forstat2 -> . expression
    (59) forstat2 -> .
    (97) expression -> . numexpression expression1
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 59 (forstat2 -> .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    IDENT           shift and go to state 64
    LPAREN          shift and go to state 65

    forstat2                       shift and go to state 290
    expression                     shift and go to state 242
    numexpression                  shift and go to state 53
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 266

    (86) statelist1 -> WHILE LPAREN expression RPAREN . statement statelist1
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 291
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 267

    (87) statelist1 -> LBRACE statelist RBRACE statelist1 .

    RBRACE          reduce using rule 87 (statelist1 -> LBRACE statelist RBRACE statelist1 .)


state 268

    (92) statelist2 -> LBRACKET numexpression RBRACKET . lvalue1 SEMICOLON statelist1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LBRACKET        shift and go to state 136
    SEMICOLON       reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 292

state 269

    (70) statelist -> IF LPAREN expression RPAREN statement . ifstat1 statelist1
    (53) ifstat1 -> . ELSE statement
    (54) ifstat1 -> .

    ELSE            shift and go to state 275
    INT             reduce using rule 54 (ifstat1 -> .)
    FLOAT           reduce using rule 54 (ifstat1 -> .)
    STRING          reduce using rule 54 (ifstat1 -> .)
    IDENT           reduce using rule 54 (ifstat1 -> .)
    PRINT           reduce using rule 54 (ifstat1 -> .)
    READ            reduce using rule 54 (ifstat1 -> .)
    RETURN          reduce using rule 54 (ifstat1 -> .)
    IF              reduce using rule 54 (ifstat1 -> .)
    FOR             reduce using rule 54 (ifstat1 -> .)
    WHILE           reduce using rule 54 (ifstat1 -> .)
    LBRACE          reduce using rule 54 (ifstat1 -> .)
    BREAK           reduce using rule 54 (ifstat1 -> .)
    SEMICOLON       reduce using rule 54 (ifstat1 -> .)
    RBRACE          reduce using rule 54 (ifstat1 -> .)

    ifstat1                        shift and go to state 293

state 270

    (71) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 . SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 294


state 271

    (72) statelist -> WHILE LPAREN expression RPAREN statement . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 295

state 272

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN . LBRACE statelist RBRACE funclist1

    LBRACE          shift and go to state 296


state 273

    (125) lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .

    MULTIPLY        reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    DIVIDE          reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    REM             reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    PLUS            reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    MINUS           reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    GT              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    LT              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    GE              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    LE              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    EQ              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    NEQ             reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    SEMICOLON       reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    RBRACKET        reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    LBRACKET        reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    COMMA           reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    RPAREN          reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    ASSIGN          reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)


state 274

    (52) ifstat -> IF LPAREN expression RPAREN statement ifstat1 .

    $end            reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    ELSE            reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    INT             reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    FLOAT           reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    STRING          reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    IDENT           reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    PRINT           reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    READ            reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    RETURN          reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    IF              reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    FOR             reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    WHILE           reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    LBRACE          reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    BREAK           reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    SEMICOLON       reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    RBRACE          reduce using rule 52 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)


state 275

    (53) ifstat1 -> ELSE . statement
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 297
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 276

    (55) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON . forstat1 RPAREN statement
    (56) forstat1 -> . IDENT forstat3
    (57) forstat1 -> .

    IDENT           shift and go to state 140
    RPAREN          reduce using rule 57 (forstat1 -> .)

    forstat1                       shift and go to state 298

state 277

    (60) forstat3 -> LBRACKET numexpression RBRACKET . lvalue1 ASSIGN atribstat1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LBRACKET        shift and go to state 136
    ASSIGN          reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 299

state 278

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE . statelist RBRACE
    (63) statelist -> . INT listdcl IDENT statelist2
    (64) statelist -> . FLOAT listdcl IDENT statelist2
    (65) statelist -> . STRING listdcl IDENT statelist2
    (66) statelist -> . IDENT statelist3
    (67) statelist -> . PRINT expression SEMICOLON statelist1
    (68) statelist -> . READ IDENT statelist2
    (69) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (70) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (71) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (72) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (73) statelist -> . LBRACE statelist RBRACE statelist1
    (74) statelist -> . BREAK SEMICOLON statelist1
    (75) statelist -> . SEMICOLON statelist1
    (76) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 37
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 38
    PRINT           shift and go to state 41
    READ            shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    FOR             shift and go to state 46
    WHILE           shift and go to state 47
    LBRACE          shift and go to state 35
    BREAK           shift and go to state 48
    SEMICOLON       shift and go to state 42

    statelist                      shift and go to state 300

state 279

    (11) paramlist -> STRING listdcl IDENT . paramlist1
    (15) paramlist1 -> . COMMA paramlist
    (16) paramlist1 -> .

    COMMA           shift and go to state 302
    RPAREN          reduce using rule 16 (paramlist1 -> .)

    paramlist1                     shift and go to state 301

state 280

    (12) paramlist -> FLOAT listdcl IDENT . paramlist1
    (15) paramlist1 -> . COMMA paramlist
    (16) paramlist1 -> .

    COMMA           shift and go to state 302
    RPAREN          reduce using rule 16 (paramlist1 -> .)

    paramlist1                     shift and go to state 303

state 281

    (13) paramlist -> INT listdcl IDENT . paramlist1
    (15) paramlist1 -> . COMMA paramlist
    (16) paramlist1 -> .

    COMMA           shift and go to state 302
    RPAREN          reduce using rule 16 (paramlist1 -> .)

    paramlist1                     shift and go to state 304

state 282

    (35) statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .

    $end            reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    ELSE            reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    INT             reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    FLOAT           reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    STRING          reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    IDENT           reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    PRINT           reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    READ            reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    RETURN          reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    IF              reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    FOR             reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    WHILE           reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    LBRACE          reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    BREAK           reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    SEMICOLON       reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)
    RBRACE          reduce using rule 35 (statement2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON .)


state 283

    (32) statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 . SEMICOLON

    SEMICOLON       shift and go to state 305


state 284

    (96) allocexpression -> NEW types LBRACKET numexpression RBRACKET . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> .

    LBRACKET        shift and go to state 136
    SEMICOLON       reduce using rule 126 (lvalue1 -> .)
    RPAREN          reduce using rule 126 (lvalue1 -> .)

    lvalue1                        shift and go to state 306

state 285

    (45) paramlistcall2 -> LBRACKET numexpression RBRACKET lvalue1 . paramlistcall1
    (43) paramlistcall1 -> . COMMA paramlistcall
    (44) paramlistcall1 -> .

    COMMA           shift and go to state 155
    RPAREN          reduce using rule 44 (paramlistcall1 -> .)

    paramlistcall1                 shift and go to state 307

state 286

    (76) statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .

    RBRACE          reduce using rule 76 (statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .)


state 287

    (94) statelist3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN . atribstat1 SEMICOLON statelist1
    (37) atribstat1 -> . expression
    (38) atribstat1 -> . allocexpression
    (39) atribstat1 -> . funccall
    (97) expression -> . numexpression expression1
    (96) allocexpression -> . NEW types LBRACKET numexpression RBRACKET lvalue1
    (40) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 81
    IDENT           shift and go to state 82
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 53
    atribstat1                     shift and go to state 308
    expression                     shift and go to state 78
    allocexpression                shift and go to state 79
    funccall                       shift and go to state 80
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 288

    (90) statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 309

state 289

    (84) statelist1 -> IF LPAREN expression RPAREN statement . ifstat1 statelist1
    (53) ifstat1 -> . ELSE statement
    (54) ifstat1 -> .

    ELSE            shift and go to state 275
    INT             reduce using rule 54 (ifstat1 -> .)
    FLOAT           reduce using rule 54 (ifstat1 -> .)
    STRING          reduce using rule 54 (ifstat1 -> .)
    IDENT           reduce using rule 54 (ifstat1 -> .)
    PRINT           reduce using rule 54 (ifstat1 -> .)
    READ            reduce using rule 54 (ifstat1 -> .)
    RETURN          reduce using rule 54 (ifstat1 -> .)
    IF              reduce using rule 54 (ifstat1 -> .)
    FOR             reduce using rule 54 (ifstat1 -> .)
    WHILE           reduce using rule 54 (ifstat1 -> .)
    LBRACE          reduce using rule 54 (ifstat1 -> .)
    BREAK           reduce using rule 54 (ifstat1 -> .)
    SEMICOLON       reduce using rule 54 (ifstat1 -> .)
    RBRACE          reduce using rule 54 (ifstat1 -> .)

    ifstat1                        shift and go to state 310

state 290

    (85) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 . SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 311


state 291

    (86) statelist1 -> WHILE LPAREN expression RPAREN statement . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 312

state 292

    (92) statelist2 -> LBRACKET numexpression RBRACKET lvalue1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 313


state 293

    (70) statelist -> IF LPAREN expression RPAREN statement ifstat1 . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 314

state 294

    (71) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON . forstat1 RPAREN statement statelist1
    (56) forstat1 -> . IDENT forstat3
    (57) forstat1 -> .

    IDENT           shift and go to state 140
    RPAREN          reduce using rule 57 (forstat1 -> .)

    forstat1                       shift and go to state 315

state 295

    (72) statelist -> WHILE LPAREN expression RPAREN statement statelist1 .

    RBRACE          reduce using rule 72 (statelist -> WHILE LPAREN expression RPAREN statement statelist1 .)


state 296

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE . statelist RBRACE funclist1
    (63) statelist -> . INT listdcl IDENT statelist2
    (64) statelist -> . FLOAT listdcl IDENT statelist2
    (65) statelist -> . STRING listdcl IDENT statelist2
    (66) statelist -> . IDENT statelist3
    (67) statelist -> . PRINT expression SEMICOLON statelist1
    (68) statelist -> . READ IDENT statelist2
    (69) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (70) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (71) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (72) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (73) statelist -> . LBRACE statelist RBRACE statelist1
    (74) statelist -> . BREAK SEMICOLON statelist1
    (75) statelist -> . SEMICOLON statelist1
    (76) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 37
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 38
    PRINT           shift and go to state 41
    READ            shift and go to state 43
    RETURN          shift and go to state 44
    IF              shift and go to state 45
    FOR             shift and go to state 46
    WHILE           shift and go to state 47
    LBRACE          shift and go to state 35
    BREAK           shift and go to state 48
    SEMICOLON       shift and go to state 42

    statelist                      shift and go to state 316

state 297

    (53) ifstat1 -> ELSE statement .

    ELSE            reduce using rule 53 (ifstat1 -> ELSE statement .)
    $end            reduce using rule 53 (ifstat1 -> ELSE statement .)
    INT             reduce using rule 53 (ifstat1 -> ELSE statement .)
    FLOAT           reduce using rule 53 (ifstat1 -> ELSE statement .)
    STRING          reduce using rule 53 (ifstat1 -> ELSE statement .)
    IDENT           reduce using rule 53 (ifstat1 -> ELSE statement .)
    PRINT           reduce using rule 53 (ifstat1 -> ELSE statement .)
    READ            reduce using rule 53 (ifstat1 -> ELSE statement .)
    RETURN          reduce using rule 53 (ifstat1 -> ELSE statement .)
    IF              reduce using rule 53 (ifstat1 -> ELSE statement .)
    FOR             reduce using rule 53 (ifstat1 -> ELSE statement .)
    WHILE           reduce using rule 53 (ifstat1 -> ELSE statement .)
    LBRACE          reduce using rule 53 (ifstat1 -> ELSE statement .)
    BREAK           reduce using rule 53 (ifstat1 -> ELSE statement .)
    SEMICOLON       reduce using rule 53 (ifstat1 -> ELSE statement .)
    RBRACE          reduce using rule 53 (ifstat1 -> ELSE statement .)


state 298

    (55) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 . RPAREN statement

    RPAREN          shift and go to state 317


state 299

    (60) forstat3 -> LBRACKET numexpression RBRACKET lvalue1 . ASSIGN atribstat1

    ASSIGN          shift and go to state 318


state 300

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist . RBRACE

    RBRACE          shift and go to state 319


state 301

    (11) paramlist -> STRING listdcl IDENT paramlist1 .

    RPAREN          reduce using rule 11 (paramlist -> STRING listdcl IDENT paramlist1 .)


state 302

    (15) paramlist1 -> COMMA . paramlist
    (11) paramlist -> . STRING listdcl IDENT paramlist1
    (12) paramlist -> . FLOAT listdcl IDENT paramlist1
    (13) paramlist -> . INT listdcl IDENT paramlist1
    (14) paramlist -> .

    STRING          shift and go to state 200
    FLOAT           shift and go to state 201
    INT             shift and go to state 202
    RPAREN          reduce using rule 14 (paramlist -> .)

    paramlist                      shift and go to state 320

state 303

    (12) paramlist -> FLOAT listdcl IDENT paramlist1 .

    RPAREN          reduce using rule 12 (paramlist -> FLOAT listdcl IDENT paramlist1 .)


state 304

    (13) paramlist -> INT listdcl IDENT paramlist1 .

    RPAREN          reduce using rule 13 (paramlist -> INT listdcl IDENT paramlist1 .)


state 305

    (32) statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .

    $end            reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    ELSE            reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    INT             reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    FLOAT           reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    STRING          reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    IDENT           reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    PRINT           reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    READ            reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    RETURN          reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    IF              reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    FOR             reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    WHILE           reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    LBRACE          reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    BREAK           reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    SEMICOLON       reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)
    RBRACE          reduce using rule 32 (statement1 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON .)


state 306

    (96) allocexpression -> NEW types LBRACKET numexpression RBRACKET lvalue1 .

    SEMICOLON       reduce using rule 96 (allocexpression -> NEW types LBRACKET numexpression RBRACKET lvalue1 .)
    RPAREN          reduce using rule 96 (allocexpression -> NEW types LBRACKET numexpression RBRACKET lvalue1 .)


state 307

    (45) paramlistcall2 -> LBRACKET numexpression RBRACKET lvalue1 paramlistcall1 .

    RPAREN          reduce using rule 45 (paramlistcall2 -> LBRACKET numexpression RBRACKET lvalue1 paramlistcall1 .)


state 308

    (94) statelist3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 321


state 309

    (90) statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .

    RBRACE          reduce using rule 90 (statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .)


state 310

    (84) statelist1 -> IF LPAREN expression RPAREN statement ifstat1 . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 322

state 311

    (85) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON . forstat1 RPAREN statement statelist1
    (56) forstat1 -> . IDENT forstat3
    (57) forstat1 -> .

    IDENT           shift and go to state 140
    RPAREN          reduce using rule 57 (forstat1 -> .)

    forstat1                       shift and go to state 323

state 312

    (86) statelist1 -> WHILE LPAREN expression RPAREN statement statelist1 .

    RBRACE          reduce using rule 86 (statelist1 -> WHILE LPAREN expression RPAREN statement statelist1 .)


state 313

    (92) statelist2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 324

state 314

    (70) statelist -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .

    RBRACE          reduce using rule 70 (statelist -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .)


state 315

    (71) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 . RPAREN statement statelist1

    RPAREN          shift and go to state 325


state 316

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist . RBRACE funclist1

    RBRACE          shift and go to state 326


state 317

    (55) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN . statement
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 327
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 318

    (60) forstat3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN . atribstat1
    (37) atribstat1 -> . expression
    (38) atribstat1 -> . allocexpression
    (39) atribstat1 -> . funccall
    (97) expression -> . numexpression expression1
    (96) allocexpression -> . NEW types LBRACKET numexpression RBRACKET lvalue1
    (40) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (106) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 81
    IDENT           shift and go to state 82
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    int_constant    shift and go to state 60
    float_constant  shift and go to state 61
    string_constant shift and go to state 62
    null_constant   shift and go to state 63
    LPAREN          shift and go to state 65

    numexpression                  shift and go to state 53
    atribstat1                     shift and go to state 328
    expression                     shift and go to state 78
    allocexpression                shift and go to state 79
    funccall                       shift and go to state 80
    term                           shift and go to state 54
    unaryexpr                      shift and go to state 55
    addsub                         shift and go to state 56
    factor                         shift and go to state 57

state 319

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE .

    DEF             reduce using rule 7 (funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE .)
    $end            reduce using rule 7 (funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE .)


state 320

    (15) paramlist1 -> COMMA paramlist .

    RPAREN          reduce using rule 15 (paramlist1 -> COMMA paramlist .)


state 321

    (94) statelist3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 329

state 322

    (84) statelist1 -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .

    RBRACE          reduce using rule 84 (statelist1 -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .)


state 323

    (85) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 . RPAREN statement statelist1

    RPAREN          shift and go to state 330


state 324

    (92) statelist2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 92 (statelist2 -> LBRACKET numexpression RBRACKET lvalue1 SEMICOLON statelist1 .)


state 325

    (71) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN . statement statelist1
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 331
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 326

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE . funclist1
    (5) funclist1 -> . DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1
    (6) funclist1 -> .

    DEF             shift and go to state 51
    $end            reduce using rule 6 (funclist1 -> .)

    funclist1                      shift and go to state 332

state 327

    (55) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .

    $end            reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    ELSE            reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    INT             reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    FLOAT           reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    STRING          reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    IDENT           reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    PRINT           reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    READ            reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    RETURN          reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    IF              reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    FOR             reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    WHILE           reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    LBRACE          reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    BREAK           reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    SEMICOLON       reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    RBRACE          reduce using rule 55 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)


state 328

    (60) forstat3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 .

    SEMICOLON       reduce using rule 60 (forstat3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 .)
    RPAREN          reduce using rule 60 (forstat3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 .)


state 329

    (94) statelist3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 94 (statelist3 -> LBRACKET numexpression RBRACKET lvalue1 ASSIGN atribstat1 SEMICOLON statelist1 .)


state 330

    (85) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN . statement statelist1
    (19) statement -> . INT IDENT statement2
    (20) statement -> . FLOAT IDENT statement2
    (21) statement -> . STRING IDENT statement2
    (22) statement -> . IDENT statement1
    (23) statement -> . printstat SEMICOLON
    (24) statement -> . readstat SEMICOLON
    (25) statement -> . returnstat SEMICOLON
    (26) statement -> . ifstat
    (27) statement -> . forstat
    (28) statement -> . whilestat
    (29) statement -> . LBRACE statelist RBRACE
    (30) statement -> . BREAK SEMICOLON
    (31) statement -> . SEMICOLON
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ expression
    (49) returnstat -> . RETURN returnstat1
    (52) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (55) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (62) whilestat -> . WHILE LPAREN expression RPAREN statement

    INT             shift and go to state 4
    FLOAT           shift and go to state 6
    STRING          shift and go to state 7
    IDENT           shift and go to state 5
    LBRACE          shift and go to state 15
    BREAK           shift and go to state 16
    SEMICOLON       shift and go to state 9
    PRINT           shift and go to state 18
    READ            shift and go to state 19
    RETURN          shift and go to state 20
    IF              shift and go to state 21
    FOR             shift and go to state 22
    WHILE           shift and go to state 23

    statement                      shift and go to state 333
    printstat                      shift and go to state 8
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    whilestat                      shift and go to state 14

state 331

    (71) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 334

state 332

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1 .

    $end            reduce using rule 5 (funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1 .)


state 333

    (85) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement . statelist1
    (77) statelist1 -> . INT listdcl IDENT statelist2
    (78) statelist1 -> . FLOAT listdcl IDENT statelist2
    (79) statelist1 -> . STRING listdcl IDENT statelist2
    (80) statelist1 -> . IDENT statelist3
    (81) statelist1 -> . PRINT expression SEMICOLON statelist1
    (82) statelist1 -> . READ IDENT statelist2
    (83) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (84) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (85) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (86) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (87) statelist1 -> . LBRACE statelist RBRACE statelist1
    (88) statelist1 -> . BREAK SEMICOLON statelist1
    (89) statelist1 -> . SEMICOLON statelist1
    (90) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (91) statelist1 -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 102
    STRING          shift and go to state 103
    IDENT           shift and go to state 101
    PRINT           shift and go to state 104
    READ            shift and go to state 105
    RETURN          shift and go to state 106
    IF              shift and go to state 107
    FOR             shift and go to state 108
    WHILE           shift and go to state 109
    LBRACE          shift and go to state 110
    BREAK           shift and go to state 111
    SEMICOLON       shift and go to state 98
    RBRACE          reduce using rule 91 (statelist1 -> .)

    statelist1                     shift and go to state 335

state 334

    (71) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .

    RBRACE          reduce using rule 71 (statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .)


state 335

    (85) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .

    RBRACE          reduce using rule 85 (statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 64 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 239 resolved as shift

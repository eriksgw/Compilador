Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> funclist
Rule 3     program -> empty
Rule 4     funclist -> funcdef funclist1
Rule 5     funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1
Rule 6     funclist1 -> empty
Rule 7     funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE
Rule 8     types -> INT
Rule 9     types -> FLOAT
Rule 10    types -> STRING
Rule 11    paramlist -> STRING listdcl IDENT paramlist1
Rule 12    paramlist -> FLOAT listdcl IDENT paramlist1
Rule 13    paramlist -> INT listdcl IDENT paramlist1
Rule 14    paramlist -> empty
Rule 15    paramlist1 -> COMMA paramlist
Rule 16    paramlist1 -> empty
Rule 17    listdcl -> LBRACKET RBRACKET listdcl
Rule 18    listdcl -> empty
Rule 19    statement -> vardecl SEMICOLON
Rule 20    statement -> atribstat SEMICOLON
Rule 21    statement -> printstat SEMICOLON
Rule 22    statement -> readstat SEMICOLON
Rule 23    statement -> returnstat SEMICOLON
Rule 24    statement -> ifstat
Rule 25    statement -> forstat
Rule 26    statement -> whilestat
Rule 27    statement -> LBRACE statelist RBRACE
Rule 28    statement -> BREAK SEMICOLON
Rule 29    statement -> SEMICOLON
Rule 30    statement -> funccall SEMICOLON
Rule 31    vardecl -> INT IDENT vardecl1
Rule 32    vardecl -> FLOAT IDENT vardecl1
Rule 33    vardecl -> STRING IDENT vardecl1
Rule 34    vardecl1 -> LBRACKET numexpression RBRACKET vardecl1
Rule 35    vardecl1 -> empty
Rule 36    atribstat -> IDENT lvalue1 atribstat1 ASSIGN atribstat2
Rule 37    atribstat1 -> LBRACKET numexpression RBRACKET atribstat1
Rule 38    atribstat1 -> empty
Rule 39    atribstat2 -> expression
Rule 40    atribstat2 -> allocexpression
Rule 41    atribstat2 -> funccall
Rule 42    funccall -> IDENT LPAREN paramlistcall RPAREN
Rule 43    paramlistcall -> factor paramlistcall1 paramlistcall2
Rule 44    paramlistcall -> empty
Rule 45    paramlistcall1 -> LBRACKET numexpression RBRACKET paramlistcall1
Rule 46    paramlistcall1 -> empty
Rule 47    paramlistcall2 -> COMMA paramlistcall
Rule 48    paramlistcall2 -> empty
Rule 49    printstat -> PRINT expression
Rule 50    readstat -> READ expression
Rule 51    returnstat -> RETURN returnstat1
Rule 52    returnstat1 -> IDENT
Rule 53    returnstat1 -> expression
Rule 54    returnstat1 -> empty
Rule 55    ifstat -> IF LPAREN expression RPAREN statement ifstat1
Rule 56    ifstat1 -> ELSE statement
Rule 57    ifstat1 -> empty
Rule 58    forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
Rule 59    forstat1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2
Rule 60    forstat1 -> empty
Rule 61    forstat2 -> expression
Rule 62    forstat2 -> empty
Rule 63    whilestat -> WHILE LPAREN expression RPAREN statement
Rule 64    statelist -> INT listdcl IDENT vardecl1 SEMICOLON statelist1
Rule 65    statelist -> FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
Rule 66    statelist -> STRING listdcl IDENT vardecl1 SEMICOLON statelist1
Rule 67    statelist -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
Rule 68    statelist -> PRINT expression SEMICOLON statelist1
Rule 69    statelist -> READ IDENT lvalue1 SEMICOLON statelist1
Rule 70    statelist -> RETURN returnstat1 SEMICOLON statelist1
Rule 71    statelist -> IF LPAREN expression RPAREN statement ifstat1 statelist1
Rule 72    statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
Rule 73    statelist -> WHILE LPAREN expression RPAREN statement statelist1
Rule 74    statelist -> LBRACE statelist RBRACE statelist1
Rule 75    statelist -> BREAK SEMICOLON statelist1
Rule 76    statelist -> SEMICOLON statelist1
Rule 77    statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
Rule 78    statelist1 -> INT listdcl IDENT vardecl1 SEMICOLON statelist1
Rule 79    statelist1 -> FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
Rule 80    statelist1 -> STRING listdcl IDENT vardecl1 SEMICOLON statelist1
Rule 81    statelist1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
Rule 82    statelist1 -> PRINT expression SEMICOLON statelist1
Rule 83    statelist1 -> READ IDENT lvalue1 SEMICOLON statelist1
Rule 84    statelist1 -> RETURN returnstat1 SEMICOLON statelist1
Rule 85    statelist1 -> IF LPAREN expression RPAREN statement ifstat1 statelist1
Rule 86    statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
Rule 87    statelist1 -> WHILE LPAREN expression RPAREN statement statelist1
Rule 88    statelist1 -> LBRACE statelist RBRACE statelist1
Rule 89    statelist1 -> BREAK SEMICOLON statelist1
Rule 90    statelist1 -> SEMICOLON statelist1
Rule 91    statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
Rule 92    statelist1 -> empty
Rule 93    allocexpression -> NEW types LBRACKET numexpression RBRACKET allocexpression1
Rule 94    allocexpression1 -> LBRACKET numexpression RBRACKET allocexpression1
Rule 95    allocexpression1 -> empty
Rule 96    expression -> numexpression expression1
Rule 97    expression1 -> compoperator numexpression
Rule 98    expression1 -> empty
Rule 99    compoperator -> GT
Rule 100   compoperator -> LT
Rule 101   compoperator -> GE
Rule 102   compoperator -> LE
Rule 103   compoperator -> EQ
Rule 104   compoperator -> NEQ
Rule 105   numexpression -> term numexpression1
Rule 106   numexpression1 -> addsub term
Rule 107   numexpression1 -> term
Rule 108   numexpression1 -> empty
Rule 109   addsub -> PLUS
Rule 110   addsub -> MINUS
Rule 111   term -> unaryexpr term1
Rule 112   term1 -> multdiv unaryexpr term1
Rule 113   term1 -> empty
Rule 114   multdiv -> MULTIPLY
Rule 115   multdiv -> DIVIDE
Rule 116   multdiv -> REM
Rule 117   unaryexpr -> addsub factor
Rule 118   unaryexpr -> factor
Rule 119   factor -> int_constant
Rule 120   factor -> float_constant
Rule 121   factor -> string_constant
Rule 122   factor -> null_constant
Rule 123   factor -> IDENT lvalue1
Rule 124   factor -> LPAREN numexpression RPAREN
Rule 125   lvalue1 -> LBRACKET numexpression RBRACKET lvalue1
Rule 126   lvalue1 -> empty
Rule 127   empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 36 59 67 81
BREAK                : 28 75 89
COMMA                : 15 47
DEF                  : 5 7
DIVIDE               : 115
ELSE                 : 56
EQ                   : 103
FLOAT                : 9 12 32 65 79
FOR                  : 58 72 86
GE                   : 101
GT                   : 99
IDENT                : 5 7 11 12 13 31 32 33 36 42 52 59 64 65 66 67 69 77 78 79 80 81 83 91 123
IF                   : 55 71 85
INT                  : 8 13 31 64 78
LBRACE               : 5 7 27 74 88
LBRACKET             : 17 34 37 45 93 94 125
LE                   : 102
LPAREN               : 5 7 42 55 58 63 71 72 73 77 85 86 87 91 124
LT                   : 100
MINUS                : 110
MULTIPLY             : 114
NEQ                  : 104
NEW                  : 93
PLUS                 : 109
PRINT                : 49 68 82
RBRACE               : 5 7 27 74 88
RBRACKET             : 17 34 37 45 93 94 125
READ                 : 50 69 83
REM                  : 116
RETURN               : 51 70 84
RPAREN               : 5 7 42 55 58 63 71 72 73 77 85 86 87 91 124
SEMICOLON            : 19 20 21 22 23 28 29 30 58 58 64 65 66 67 68 69 70 72 72 75 76 77 78 79 80 81 82 83 84 86 86 89 90 91
STRING               : 10 11 33 66 80
WHILE                : 63 73 87
error                : 
float_constant       : 120
int_constant         : 119
null_constant        : 122
string_constant      : 121

Nonterminals, with rules where they appear

addsub               : 106 117
allocexpression      : 40
allocexpression1     : 93 94
atribstat            : 20
atribstat1           : 36 37 59 67 81
atribstat2           : 36 59 67 81
compoperator         : 97
empty                : 3 6 14 16 18 35 38 44 46 48 54 57 60 62 92 95 98 108 113 126
expression           : 39 49 50 53 55 61 63 68 71 73 82 85 87
expression1          : 96
factor               : 43 117 118
forstat              : 25
forstat1             : 58 58 72 72 86 86
forstat2             : 58 72 86
funccall             : 30 41
funcdef              : 4
funclist             : 2
funclist1            : 4 5
ifstat               : 24
ifstat1              : 55 71 85
listdcl              : 11 12 13 17 64 65 66 78 79 80
lvalue1              : 36 59 67 69 81 83 123 125
multdiv              : 112
numexpression        : 34 37 45 93 94 96 97 124 125
numexpression1       : 105
paramlist            : 5 7 15
paramlist1           : 11 12 13
paramlistcall        : 42 47 77 91
paramlistcall1       : 43 45
paramlistcall2       : 43
printstat            : 21
program              : 0
readstat             : 22
returnstat           : 23
returnstat1          : 51 70 84
statelist            : 5 7 27 74 88
statelist1           : 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
statement            : 1 55 56 58 63 71 72 73 85 86 87
term                 : 105 106 107
term1                : 111 112
types                : 93
unaryexpr            : 111 112
vardecl              : 19
vardecl1             : 31 32 33 34 64 65 66 78 79 80
whilestat            : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . funclist
    (3) program -> . empty
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (4) funclist -> . funcdef funclist1
    (127) empty -> .
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (7) funcdef -> . DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    $end            reduce using rule 127 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27
    DEF             shift and go to state 28

    program                        shift and go to state 1
    statement                      shift and go to state 2
    funclist                       shift and go to state 3
    empty                          shift and go to state 4
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16
    funcdef                        shift and go to state 17

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) program -> funclist .

    $end            reduce using rule 2 (program -> funclist .)


state 4

    (3) program -> empty .

    $end            reduce using rule 3 (program -> empty .)


state 5

    (19) statement -> vardecl . SEMICOLON

    SEMICOLON       shift and go to state 29


state 6

    (29) statement -> SEMICOLON .

    $end            reduce using rule 29 (statement -> SEMICOLON .)
    ELSE            reduce using rule 29 (statement -> SEMICOLON .)
    INT             reduce using rule 29 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 29 (statement -> SEMICOLON .)
    STRING          reduce using rule 29 (statement -> SEMICOLON .)
    IDENT           reduce using rule 29 (statement -> SEMICOLON .)
    PRINT           reduce using rule 29 (statement -> SEMICOLON .)
    READ            reduce using rule 29 (statement -> SEMICOLON .)
    RETURN          reduce using rule 29 (statement -> SEMICOLON .)
    IF              reduce using rule 29 (statement -> SEMICOLON .)
    FOR             reduce using rule 29 (statement -> SEMICOLON .)
    WHILE           reduce using rule 29 (statement -> SEMICOLON .)
    LBRACE          reduce using rule 29 (statement -> SEMICOLON .)
    BREAK           reduce using rule 29 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 29 (statement -> SEMICOLON .)
    RBRACE          reduce using rule 29 (statement -> SEMICOLON .)


state 7

    (20) statement -> atribstat . SEMICOLON

    SEMICOLON       shift and go to state 30


state 8

    (21) statement -> printstat . SEMICOLON

    SEMICOLON       shift and go to state 31


state 9

    (22) statement -> readstat . SEMICOLON

    SEMICOLON       shift and go to state 32


state 10

    (23) statement -> returnstat . SEMICOLON

    SEMICOLON       shift and go to state 33


state 11

    (24) statement -> ifstat .

    $end            reduce using rule 24 (statement -> ifstat .)
    ELSE            reduce using rule 24 (statement -> ifstat .)
    INT             reduce using rule 24 (statement -> ifstat .)
    FLOAT           reduce using rule 24 (statement -> ifstat .)
    STRING          reduce using rule 24 (statement -> ifstat .)
    IDENT           reduce using rule 24 (statement -> ifstat .)
    PRINT           reduce using rule 24 (statement -> ifstat .)
    READ            reduce using rule 24 (statement -> ifstat .)
    RETURN          reduce using rule 24 (statement -> ifstat .)
    IF              reduce using rule 24 (statement -> ifstat .)
    FOR             reduce using rule 24 (statement -> ifstat .)
    WHILE           reduce using rule 24 (statement -> ifstat .)
    LBRACE          reduce using rule 24 (statement -> ifstat .)
    BREAK           reduce using rule 24 (statement -> ifstat .)
    SEMICOLON       reduce using rule 24 (statement -> ifstat .)
    RBRACE          reduce using rule 24 (statement -> ifstat .)


state 12

    (25) statement -> forstat .

    $end            reduce using rule 25 (statement -> forstat .)
    ELSE            reduce using rule 25 (statement -> forstat .)
    INT             reduce using rule 25 (statement -> forstat .)
    FLOAT           reduce using rule 25 (statement -> forstat .)
    STRING          reduce using rule 25 (statement -> forstat .)
    IDENT           reduce using rule 25 (statement -> forstat .)
    PRINT           reduce using rule 25 (statement -> forstat .)
    READ            reduce using rule 25 (statement -> forstat .)
    RETURN          reduce using rule 25 (statement -> forstat .)
    IF              reduce using rule 25 (statement -> forstat .)
    FOR             reduce using rule 25 (statement -> forstat .)
    WHILE           reduce using rule 25 (statement -> forstat .)
    LBRACE          reduce using rule 25 (statement -> forstat .)
    BREAK           reduce using rule 25 (statement -> forstat .)
    SEMICOLON       reduce using rule 25 (statement -> forstat .)
    RBRACE          reduce using rule 25 (statement -> forstat .)


state 13

    (26) statement -> whilestat .

    $end            reduce using rule 26 (statement -> whilestat .)
    ELSE            reduce using rule 26 (statement -> whilestat .)
    INT             reduce using rule 26 (statement -> whilestat .)
    FLOAT           reduce using rule 26 (statement -> whilestat .)
    STRING          reduce using rule 26 (statement -> whilestat .)
    IDENT           reduce using rule 26 (statement -> whilestat .)
    PRINT           reduce using rule 26 (statement -> whilestat .)
    READ            reduce using rule 26 (statement -> whilestat .)
    RETURN          reduce using rule 26 (statement -> whilestat .)
    IF              reduce using rule 26 (statement -> whilestat .)
    FOR             reduce using rule 26 (statement -> whilestat .)
    WHILE           reduce using rule 26 (statement -> whilestat .)
    LBRACE          reduce using rule 26 (statement -> whilestat .)
    BREAK           reduce using rule 26 (statement -> whilestat .)
    SEMICOLON       reduce using rule 26 (statement -> whilestat .)
    RBRACE          reduce using rule 26 (statement -> whilestat .)


state 14

    (27) statement -> LBRACE . statelist RBRACE
    (64) statelist -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (65) statelist -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (66) statelist -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (67) statelist -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (68) statelist -> . PRINT expression SEMICOLON statelist1
    (69) statelist -> . READ IDENT lvalue1 SEMICOLON statelist1
    (70) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (71) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (72) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (73) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (74) statelist -> . LBRACE statelist RBRACE statelist1
    (75) statelist -> . BREAK SEMICOLON statelist1
    (76) statelist -> . SEMICOLON statelist1
    (77) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 36
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 37
    PRINT           shift and go to state 41
    READ            shift and go to state 42
    RETURN          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    LBRACE          shift and go to state 34
    BREAK           shift and go to state 47
    SEMICOLON       shift and go to state 38

    statelist                      shift and go to state 35

state 15

    (28) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 48


state 16

    (30) statement -> funccall . SEMICOLON

    SEMICOLON       shift and go to state 49


state 17

    (4) funclist -> funcdef . funclist1
    (5) funclist1 -> . DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1
    (6) funclist1 -> . empty
    (127) empty -> .

    DEF             shift and go to state 51
    $end            reduce using rule 127 (empty -> .)

    funclist1                      shift and go to state 50
    empty                          shift and go to state 52

state 18

    (31) vardecl -> INT . IDENT vardecl1

    IDENT           shift and go to state 53


state 19

    (36) atribstat -> IDENT . lvalue1 atribstat1 ASSIGN atribstat2
    (42) funccall -> IDENT . LPAREN paramlistcall RPAREN
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 55
    LBRACKET        shift and go to state 56
    ASSIGN          reduce using rule 127 (empty -> .)

  ! LBRACKET        [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 54
    empty                          shift and go to state 57

state 20

    (32) vardecl -> FLOAT . IDENT vardecl1

    IDENT           shift and go to state 58


state 21

    (33) vardecl -> STRING . IDENT vardecl1

    IDENT           shift and go to state 59


state 22

    (49) printstat -> PRINT . expression
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 60
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 23

    (50) readstat -> READ . expression
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 74
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 24

    (51) returnstat -> RETURN . returnstat1
    (52) returnstat1 -> . IDENT
    (53) returnstat1 -> . expression
    (54) returnstat1 -> . empty
    (96) expression -> . numexpression expression1
    (127) empty -> .
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    IDENT           shift and go to state 76
    SEMICOLON       reduce using rule 127 (empty -> .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    LPAREN          shift and go to state 73

    returnstat1                    shift and go to state 75
    expression                     shift and go to state 77
    empty                          shift and go to state 78
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 25

    (55) ifstat -> IF . LPAREN expression RPAREN statement ifstat1

    LPAREN          shift and go to state 79


state 26

    (58) forstat -> FOR . LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement

    LPAREN          shift and go to state 80


state 27

    (63) whilestat -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 81


state 28

    (7) funcdef -> DEF . IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE

    IDENT           shift and go to state 82


state 29

    (19) statement -> vardecl SEMICOLON .

    $end            reduce using rule 19 (statement -> vardecl SEMICOLON .)
    ELSE            reduce using rule 19 (statement -> vardecl SEMICOLON .)
    INT             reduce using rule 19 (statement -> vardecl SEMICOLON .)
    FLOAT           reduce using rule 19 (statement -> vardecl SEMICOLON .)
    STRING          reduce using rule 19 (statement -> vardecl SEMICOLON .)
    IDENT           reduce using rule 19 (statement -> vardecl SEMICOLON .)
    PRINT           reduce using rule 19 (statement -> vardecl SEMICOLON .)
    READ            reduce using rule 19 (statement -> vardecl SEMICOLON .)
    RETURN          reduce using rule 19 (statement -> vardecl SEMICOLON .)
    IF              reduce using rule 19 (statement -> vardecl SEMICOLON .)
    FOR             reduce using rule 19 (statement -> vardecl SEMICOLON .)
    WHILE           reduce using rule 19 (statement -> vardecl SEMICOLON .)
    LBRACE          reduce using rule 19 (statement -> vardecl SEMICOLON .)
    BREAK           reduce using rule 19 (statement -> vardecl SEMICOLON .)
    SEMICOLON       reduce using rule 19 (statement -> vardecl SEMICOLON .)
    RBRACE          reduce using rule 19 (statement -> vardecl SEMICOLON .)


state 30

    (20) statement -> atribstat SEMICOLON .

    $end            reduce using rule 20 (statement -> atribstat SEMICOLON .)
    ELSE            reduce using rule 20 (statement -> atribstat SEMICOLON .)
    INT             reduce using rule 20 (statement -> atribstat SEMICOLON .)
    FLOAT           reduce using rule 20 (statement -> atribstat SEMICOLON .)
    STRING          reduce using rule 20 (statement -> atribstat SEMICOLON .)
    IDENT           reduce using rule 20 (statement -> atribstat SEMICOLON .)
    PRINT           reduce using rule 20 (statement -> atribstat SEMICOLON .)
    READ            reduce using rule 20 (statement -> atribstat SEMICOLON .)
    RETURN          reduce using rule 20 (statement -> atribstat SEMICOLON .)
    IF              reduce using rule 20 (statement -> atribstat SEMICOLON .)
    FOR             reduce using rule 20 (statement -> atribstat SEMICOLON .)
    WHILE           reduce using rule 20 (statement -> atribstat SEMICOLON .)
    LBRACE          reduce using rule 20 (statement -> atribstat SEMICOLON .)
    BREAK           reduce using rule 20 (statement -> atribstat SEMICOLON .)
    SEMICOLON       reduce using rule 20 (statement -> atribstat SEMICOLON .)
    RBRACE          reduce using rule 20 (statement -> atribstat SEMICOLON .)


state 31

    (21) statement -> printstat SEMICOLON .

    $end            reduce using rule 21 (statement -> printstat SEMICOLON .)
    ELSE            reduce using rule 21 (statement -> printstat SEMICOLON .)
    INT             reduce using rule 21 (statement -> printstat SEMICOLON .)
    FLOAT           reduce using rule 21 (statement -> printstat SEMICOLON .)
    STRING          reduce using rule 21 (statement -> printstat SEMICOLON .)
    IDENT           reduce using rule 21 (statement -> printstat SEMICOLON .)
    PRINT           reduce using rule 21 (statement -> printstat SEMICOLON .)
    READ            reduce using rule 21 (statement -> printstat SEMICOLON .)
    RETURN          reduce using rule 21 (statement -> printstat SEMICOLON .)
    IF              reduce using rule 21 (statement -> printstat SEMICOLON .)
    FOR             reduce using rule 21 (statement -> printstat SEMICOLON .)
    WHILE           reduce using rule 21 (statement -> printstat SEMICOLON .)
    LBRACE          reduce using rule 21 (statement -> printstat SEMICOLON .)
    BREAK           reduce using rule 21 (statement -> printstat SEMICOLON .)
    SEMICOLON       reduce using rule 21 (statement -> printstat SEMICOLON .)
    RBRACE          reduce using rule 21 (statement -> printstat SEMICOLON .)


state 32

    (22) statement -> readstat SEMICOLON .

    $end            reduce using rule 22 (statement -> readstat SEMICOLON .)
    ELSE            reduce using rule 22 (statement -> readstat SEMICOLON .)
    INT             reduce using rule 22 (statement -> readstat SEMICOLON .)
    FLOAT           reduce using rule 22 (statement -> readstat SEMICOLON .)
    STRING          reduce using rule 22 (statement -> readstat SEMICOLON .)
    IDENT           reduce using rule 22 (statement -> readstat SEMICOLON .)
    PRINT           reduce using rule 22 (statement -> readstat SEMICOLON .)
    READ            reduce using rule 22 (statement -> readstat SEMICOLON .)
    RETURN          reduce using rule 22 (statement -> readstat SEMICOLON .)
    IF              reduce using rule 22 (statement -> readstat SEMICOLON .)
    FOR             reduce using rule 22 (statement -> readstat SEMICOLON .)
    WHILE           reduce using rule 22 (statement -> readstat SEMICOLON .)
    LBRACE          reduce using rule 22 (statement -> readstat SEMICOLON .)
    BREAK           reduce using rule 22 (statement -> readstat SEMICOLON .)
    SEMICOLON       reduce using rule 22 (statement -> readstat SEMICOLON .)
    RBRACE          reduce using rule 22 (statement -> readstat SEMICOLON .)


state 33

    (23) statement -> returnstat SEMICOLON .

    $end            reduce using rule 23 (statement -> returnstat SEMICOLON .)
    ELSE            reduce using rule 23 (statement -> returnstat SEMICOLON .)
    INT             reduce using rule 23 (statement -> returnstat SEMICOLON .)
    FLOAT           reduce using rule 23 (statement -> returnstat SEMICOLON .)
    STRING          reduce using rule 23 (statement -> returnstat SEMICOLON .)
    IDENT           reduce using rule 23 (statement -> returnstat SEMICOLON .)
    PRINT           reduce using rule 23 (statement -> returnstat SEMICOLON .)
    READ            reduce using rule 23 (statement -> returnstat SEMICOLON .)
    RETURN          reduce using rule 23 (statement -> returnstat SEMICOLON .)
    IF              reduce using rule 23 (statement -> returnstat SEMICOLON .)
    FOR             reduce using rule 23 (statement -> returnstat SEMICOLON .)
    WHILE           reduce using rule 23 (statement -> returnstat SEMICOLON .)
    LBRACE          reduce using rule 23 (statement -> returnstat SEMICOLON .)
    BREAK           reduce using rule 23 (statement -> returnstat SEMICOLON .)
    SEMICOLON       reduce using rule 23 (statement -> returnstat SEMICOLON .)
    RBRACE          reduce using rule 23 (statement -> returnstat SEMICOLON .)


state 34

    (74) statelist -> LBRACE . statelist RBRACE statelist1
    (64) statelist -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (65) statelist -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (66) statelist -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (67) statelist -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (68) statelist -> . PRINT expression SEMICOLON statelist1
    (69) statelist -> . READ IDENT lvalue1 SEMICOLON statelist1
    (70) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (71) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (72) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (73) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (74) statelist -> . LBRACE statelist RBRACE statelist1
    (75) statelist -> . BREAK SEMICOLON statelist1
    (76) statelist -> . SEMICOLON statelist1
    (77) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 36
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 37
    PRINT           shift and go to state 41
    READ            shift and go to state 42
    RETURN          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    LBRACE          shift and go to state 34
    BREAK           shift and go to state 47
    SEMICOLON       shift and go to state 38

    statelist                      shift and go to state 83

state 35

    (27) statement -> LBRACE statelist . RBRACE

    RBRACE          shift and go to state 84


state 36

    (64) statelist -> INT . listdcl IDENT vardecl1 SEMICOLON statelist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 85
    empty                          shift and go to state 87

state 37

    (67) statelist -> IDENT . lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (77) statelist -> IDENT . LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 89
    LBRACKET        shift and go to state 56
    ASSIGN          reduce using rule 127 (empty -> .)

  ! LBRACKET        [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 88
    empty                          shift and go to state 57

state 38

    (76) statelist -> SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 91
    empty                          shift and go to state 104

state 39

    (65) statelist -> FLOAT . listdcl IDENT vardecl1 SEMICOLON statelist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 105
    empty                          shift and go to state 87

state 40

    (66) statelist -> STRING . listdcl IDENT vardecl1 SEMICOLON statelist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 106
    empty                          shift and go to state 87

state 41

    (68) statelist -> PRINT . expression SEMICOLON statelist1
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 107
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 42

    (69) statelist -> READ . IDENT lvalue1 SEMICOLON statelist1

    IDENT           shift and go to state 108


state 43

    (70) statelist -> RETURN . returnstat1 SEMICOLON statelist1
    (52) returnstat1 -> . IDENT
    (53) returnstat1 -> . expression
    (54) returnstat1 -> . empty
    (96) expression -> . numexpression expression1
    (127) empty -> .
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    IDENT           shift and go to state 76
    SEMICOLON       reduce using rule 127 (empty -> .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    LPAREN          shift and go to state 73

    returnstat1                    shift and go to state 109
    expression                     shift and go to state 77
    empty                          shift and go to state 78
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 44

    (71) statelist -> IF . LPAREN expression RPAREN statement ifstat1 statelist1

    LPAREN          shift and go to state 110


state 45

    (72) statelist -> FOR . LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    LPAREN          shift and go to state 111


state 46

    (73) statelist -> WHILE . LPAREN expression RPAREN statement statelist1

    LPAREN          shift and go to state 112


state 47

    (75) statelist -> BREAK . SEMICOLON statelist1

    SEMICOLON       shift and go to state 113


state 48

    (28) statement -> BREAK SEMICOLON .

    $end            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    INT             reduce using rule 28 (statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    IDENT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    READ            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 28 (statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 28 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 28 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 28 (statement -> BREAK SEMICOLON .)


state 49

    (30) statement -> funccall SEMICOLON .

    $end            reduce using rule 30 (statement -> funccall SEMICOLON .)
    ELSE            reduce using rule 30 (statement -> funccall SEMICOLON .)
    INT             reduce using rule 30 (statement -> funccall SEMICOLON .)
    FLOAT           reduce using rule 30 (statement -> funccall SEMICOLON .)
    STRING          reduce using rule 30 (statement -> funccall SEMICOLON .)
    IDENT           reduce using rule 30 (statement -> funccall SEMICOLON .)
    PRINT           reduce using rule 30 (statement -> funccall SEMICOLON .)
    READ            reduce using rule 30 (statement -> funccall SEMICOLON .)
    RETURN          reduce using rule 30 (statement -> funccall SEMICOLON .)
    IF              reduce using rule 30 (statement -> funccall SEMICOLON .)
    FOR             reduce using rule 30 (statement -> funccall SEMICOLON .)
    WHILE           reduce using rule 30 (statement -> funccall SEMICOLON .)
    LBRACE          reduce using rule 30 (statement -> funccall SEMICOLON .)
    BREAK           reduce using rule 30 (statement -> funccall SEMICOLON .)
    SEMICOLON       reduce using rule 30 (statement -> funccall SEMICOLON .)
    RBRACE          reduce using rule 30 (statement -> funccall SEMICOLON .)


state 50

    (4) funclist -> funcdef funclist1 .

    $end            reduce using rule 4 (funclist -> funcdef funclist1 .)


state 51

    (5) funclist1 -> DEF . IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1

    IDENT           shift and go to state 114


state 52

    (6) funclist1 -> empty .

    $end            reduce using rule 6 (funclist1 -> empty .)


state 53

    (31) vardecl -> INT IDENT . vardecl1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 115
    empty                          shift and go to state 117

state 54

    (36) atribstat -> IDENT lvalue1 . atribstat1 ASSIGN atribstat2
    (37) atribstat1 -> . LBRACKET numexpression RBRACKET atribstat1
    (38) atribstat1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 119
    ASSIGN          reduce using rule 127 (empty -> .)

    atribstat1                     shift and go to state 118
    empty                          shift and go to state 120

state 55

    (42) funccall -> IDENT LPAREN . paramlistcall RPAREN
    (43) paramlistcall -> . factor paramlistcall1 paramlistcall2
    (44) paramlistcall -> . empty
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN
    (127) empty -> .

    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73
    RPAREN          reduce using rule 127 (empty -> .)

    paramlistcall                  shift and go to state 121
    factor                         shift and go to state 122
    empty                          shift and go to state 123

state 56

    (125) lvalue1 -> LBRACKET . numexpression RBRACKET lvalue1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 124
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 57

    (126) lvalue1 -> empty .

    LBRACKET        reduce using rule 126 (lvalue1 -> empty .)
    ASSIGN          reduce using rule 126 (lvalue1 -> empty .)
    MULTIPLY        reduce using rule 126 (lvalue1 -> empty .)
    DIVIDE          reduce using rule 126 (lvalue1 -> empty .)
    REM             reduce using rule 126 (lvalue1 -> empty .)
    PLUS            reduce using rule 126 (lvalue1 -> empty .)
    MINUS           reduce using rule 126 (lvalue1 -> empty .)
    int_constant    reduce using rule 126 (lvalue1 -> empty .)
    float_constant  reduce using rule 126 (lvalue1 -> empty .)
    string_constant reduce using rule 126 (lvalue1 -> empty .)
    null_constant   reduce using rule 126 (lvalue1 -> empty .)
    IDENT           reduce using rule 126 (lvalue1 -> empty .)
    LPAREN          reduce using rule 126 (lvalue1 -> empty .)
    GT              reduce using rule 126 (lvalue1 -> empty .)
    LT              reduce using rule 126 (lvalue1 -> empty .)
    GE              reduce using rule 126 (lvalue1 -> empty .)
    LE              reduce using rule 126 (lvalue1 -> empty .)
    EQ              reduce using rule 126 (lvalue1 -> empty .)
    NEQ             reduce using rule 126 (lvalue1 -> empty .)
    SEMICOLON       reduce using rule 126 (lvalue1 -> empty .)
    COMMA           reduce using rule 126 (lvalue1 -> empty .)
    RPAREN          reduce using rule 126 (lvalue1 -> empty .)
    RBRACKET        reduce using rule 126 (lvalue1 -> empty .)


state 58

    (32) vardecl -> FLOAT IDENT . vardecl1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 125
    empty                          shift and go to state 117

state 59

    (33) vardecl -> STRING IDENT . vardecl1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 126
    empty                          shift and go to state 117

state 60

    (49) printstat -> PRINT expression .

    SEMICOLON       reduce using rule 49 (printstat -> PRINT expression .)


state 61

    (96) expression -> numexpression . expression1
    (97) expression1 -> . compoperator numexpression
    (98) expression1 -> . empty
    (99) compoperator -> . GT
    (100) compoperator -> . LT
    (101) compoperator -> . GE
    (102) compoperator -> . LE
    (103) compoperator -> . EQ
    (104) compoperator -> . NEQ
    (127) empty -> .

    GT              shift and go to state 130
    LT              shift and go to state 131
    GE              shift and go to state 132
    LE              shift and go to state 133
    EQ              shift and go to state 134
    NEQ             shift and go to state 135
    SEMICOLON       reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    expression1                    shift and go to state 127
    compoperator                   shift and go to state 128
    empty                          shift and go to state 129

state 62

    (105) numexpression -> term . numexpression1
    (106) numexpression1 -> . addsub term
    (107) numexpression1 -> . term
    (108) numexpression1 -> . empty
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (111) term -> . unaryexpr term1
    (127) empty -> .
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    GT              reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GE              reduce using rule 127 (empty -> .)
    LE              reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    RBRACKET        reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    term                           shift and go to state 136
    numexpression1                 shift and go to state 137
    addsub                         shift and go to state 138
    empty                          shift and go to state 139
    unaryexpr                      shift and go to state 63
    factor                         shift and go to state 65

state 63

    (111) term -> unaryexpr . term1
    (112) term1 -> . multdiv unaryexpr term1
    (113) term1 -> . empty
    (114) multdiv -> . MULTIPLY
    (115) multdiv -> . DIVIDE
    (116) multdiv -> . REM
    (127) empty -> .

    MULTIPLY        shift and go to state 143
    DIVIDE          shift and go to state 144
    REM             shift and go to state 145
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    int_constant    reduce using rule 127 (empty -> .)
    float_constant  reduce using rule 127 (empty -> .)
    string_constant reduce using rule 127 (empty -> .)
    null_constant   reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    LPAREN          reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GE              reduce using rule 127 (empty -> .)
    LE              reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    RBRACKET        reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    term1                          shift and go to state 140
    multdiv                        shift and go to state 141
    empty                          shift and go to state 142

state 64

    (117) unaryexpr -> addsub . factor
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    factor                         shift and go to state 146

state 65

    (118) unaryexpr -> factor .

    MULTIPLY        reduce using rule 118 (unaryexpr -> factor .)
    DIVIDE          reduce using rule 118 (unaryexpr -> factor .)
    REM             reduce using rule 118 (unaryexpr -> factor .)
    PLUS            reduce using rule 118 (unaryexpr -> factor .)
    MINUS           reduce using rule 118 (unaryexpr -> factor .)
    int_constant    reduce using rule 118 (unaryexpr -> factor .)
    float_constant  reduce using rule 118 (unaryexpr -> factor .)
    string_constant reduce using rule 118 (unaryexpr -> factor .)
    null_constant   reduce using rule 118 (unaryexpr -> factor .)
    IDENT           reduce using rule 118 (unaryexpr -> factor .)
    LPAREN          reduce using rule 118 (unaryexpr -> factor .)
    GT              reduce using rule 118 (unaryexpr -> factor .)
    LT              reduce using rule 118 (unaryexpr -> factor .)
    GE              reduce using rule 118 (unaryexpr -> factor .)
    LE              reduce using rule 118 (unaryexpr -> factor .)
    EQ              reduce using rule 118 (unaryexpr -> factor .)
    NEQ             reduce using rule 118 (unaryexpr -> factor .)
    SEMICOLON       reduce using rule 118 (unaryexpr -> factor .)
    RBRACKET        reduce using rule 118 (unaryexpr -> factor .)
    RPAREN          reduce using rule 118 (unaryexpr -> factor .)


state 66

    (109) addsub -> PLUS .

    int_constant    reduce using rule 109 (addsub -> PLUS .)
    float_constant  reduce using rule 109 (addsub -> PLUS .)
    string_constant reduce using rule 109 (addsub -> PLUS .)
    null_constant   reduce using rule 109 (addsub -> PLUS .)
    IDENT           reduce using rule 109 (addsub -> PLUS .)
    LPAREN          reduce using rule 109 (addsub -> PLUS .)
    PLUS            reduce using rule 109 (addsub -> PLUS .)
    MINUS           reduce using rule 109 (addsub -> PLUS .)


state 67

    (110) addsub -> MINUS .

    int_constant    reduce using rule 110 (addsub -> MINUS .)
    float_constant  reduce using rule 110 (addsub -> MINUS .)
    string_constant reduce using rule 110 (addsub -> MINUS .)
    null_constant   reduce using rule 110 (addsub -> MINUS .)
    IDENT           reduce using rule 110 (addsub -> MINUS .)
    LPAREN          reduce using rule 110 (addsub -> MINUS .)
    PLUS            reduce using rule 110 (addsub -> MINUS .)
    MINUS           reduce using rule 110 (addsub -> MINUS .)


state 68

    (119) factor -> int_constant .

    MULTIPLY        reduce using rule 119 (factor -> int_constant .)
    DIVIDE          reduce using rule 119 (factor -> int_constant .)
    REM             reduce using rule 119 (factor -> int_constant .)
    PLUS            reduce using rule 119 (factor -> int_constant .)
    MINUS           reduce using rule 119 (factor -> int_constant .)
    int_constant    reduce using rule 119 (factor -> int_constant .)
    float_constant  reduce using rule 119 (factor -> int_constant .)
    string_constant reduce using rule 119 (factor -> int_constant .)
    null_constant   reduce using rule 119 (factor -> int_constant .)
    IDENT           reduce using rule 119 (factor -> int_constant .)
    LPAREN          reduce using rule 119 (factor -> int_constant .)
    GT              reduce using rule 119 (factor -> int_constant .)
    LT              reduce using rule 119 (factor -> int_constant .)
    GE              reduce using rule 119 (factor -> int_constant .)
    LE              reduce using rule 119 (factor -> int_constant .)
    EQ              reduce using rule 119 (factor -> int_constant .)
    NEQ             reduce using rule 119 (factor -> int_constant .)
    SEMICOLON       reduce using rule 119 (factor -> int_constant .)
    LBRACKET        reduce using rule 119 (factor -> int_constant .)
    COMMA           reduce using rule 119 (factor -> int_constant .)
    RPAREN          reduce using rule 119 (factor -> int_constant .)
    RBRACKET        reduce using rule 119 (factor -> int_constant .)


state 69

    (120) factor -> float_constant .

    MULTIPLY        reduce using rule 120 (factor -> float_constant .)
    DIVIDE          reduce using rule 120 (factor -> float_constant .)
    REM             reduce using rule 120 (factor -> float_constant .)
    PLUS            reduce using rule 120 (factor -> float_constant .)
    MINUS           reduce using rule 120 (factor -> float_constant .)
    int_constant    reduce using rule 120 (factor -> float_constant .)
    float_constant  reduce using rule 120 (factor -> float_constant .)
    string_constant reduce using rule 120 (factor -> float_constant .)
    null_constant   reduce using rule 120 (factor -> float_constant .)
    IDENT           reduce using rule 120 (factor -> float_constant .)
    LPAREN          reduce using rule 120 (factor -> float_constant .)
    GT              reduce using rule 120 (factor -> float_constant .)
    LT              reduce using rule 120 (factor -> float_constant .)
    GE              reduce using rule 120 (factor -> float_constant .)
    LE              reduce using rule 120 (factor -> float_constant .)
    EQ              reduce using rule 120 (factor -> float_constant .)
    NEQ             reduce using rule 120 (factor -> float_constant .)
    SEMICOLON       reduce using rule 120 (factor -> float_constant .)
    LBRACKET        reduce using rule 120 (factor -> float_constant .)
    COMMA           reduce using rule 120 (factor -> float_constant .)
    RPAREN          reduce using rule 120 (factor -> float_constant .)
    RBRACKET        reduce using rule 120 (factor -> float_constant .)


state 70

    (121) factor -> string_constant .

    MULTIPLY        reduce using rule 121 (factor -> string_constant .)
    DIVIDE          reduce using rule 121 (factor -> string_constant .)
    REM             reduce using rule 121 (factor -> string_constant .)
    PLUS            reduce using rule 121 (factor -> string_constant .)
    MINUS           reduce using rule 121 (factor -> string_constant .)
    int_constant    reduce using rule 121 (factor -> string_constant .)
    float_constant  reduce using rule 121 (factor -> string_constant .)
    string_constant reduce using rule 121 (factor -> string_constant .)
    null_constant   reduce using rule 121 (factor -> string_constant .)
    IDENT           reduce using rule 121 (factor -> string_constant .)
    LPAREN          reduce using rule 121 (factor -> string_constant .)
    GT              reduce using rule 121 (factor -> string_constant .)
    LT              reduce using rule 121 (factor -> string_constant .)
    GE              reduce using rule 121 (factor -> string_constant .)
    LE              reduce using rule 121 (factor -> string_constant .)
    EQ              reduce using rule 121 (factor -> string_constant .)
    NEQ             reduce using rule 121 (factor -> string_constant .)
    SEMICOLON       reduce using rule 121 (factor -> string_constant .)
    LBRACKET        reduce using rule 121 (factor -> string_constant .)
    COMMA           reduce using rule 121 (factor -> string_constant .)
    RPAREN          reduce using rule 121 (factor -> string_constant .)
    RBRACKET        reduce using rule 121 (factor -> string_constant .)


state 71

    (122) factor -> null_constant .

    MULTIPLY        reduce using rule 122 (factor -> null_constant .)
    DIVIDE          reduce using rule 122 (factor -> null_constant .)
    REM             reduce using rule 122 (factor -> null_constant .)
    PLUS            reduce using rule 122 (factor -> null_constant .)
    MINUS           reduce using rule 122 (factor -> null_constant .)
    int_constant    reduce using rule 122 (factor -> null_constant .)
    float_constant  reduce using rule 122 (factor -> null_constant .)
    string_constant reduce using rule 122 (factor -> null_constant .)
    null_constant   reduce using rule 122 (factor -> null_constant .)
    IDENT           reduce using rule 122 (factor -> null_constant .)
    LPAREN          reduce using rule 122 (factor -> null_constant .)
    GT              reduce using rule 122 (factor -> null_constant .)
    LT              reduce using rule 122 (factor -> null_constant .)
    GE              reduce using rule 122 (factor -> null_constant .)
    LE              reduce using rule 122 (factor -> null_constant .)
    EQ              reduce using rule 122 (factor -> null_constant .)
    NEQ             reduce using rule 122 (factor -> null_constant .)
    SEMICOLON       reduce using rule 122 (factor -> null_constant .)
    LBRACKET        reduce using rule 122 (factor -> null_constant .)
    COMMA           reduce using rule 122 (factor -> null_constant .)
    RPAREN          reduce using rule 122 (factor -> null_constant .)
    RBRACKET        reduce using rule 122 (factor -> null_constant .)


state 72

    (123) factor -> IDENT . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 56
    MULTIPLY        reduce using rule 127 (empty -> .)
    DIVIDE          reduce using rule 127 (empty -> .)
    REM             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    int_constant    reduce using rule 127 (empty -> .)
    float_constant  reduce using rule 127 (empty -> .)
    string_constant reduce using rule 127 (empty -> .)
    null_constant   reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    LPAREN          reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GE              reduce using rule 127 (empty -> .)
    LE              reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    RBRACKET        reduce using rule 127 (empty -> .)

  ! LBRACKET        [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 147
    empty                          shift and go to state 57

state 73

    (124) factor -> LPAREN . numexpression RPAREN
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 148
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 74

    (50) readstat -> READ expression .

    SEMICOLON       reduce using rule 50 (readstat -> READ expression .)


state 75

    (51) returnstat -> RETURN returnstat1 .

    SEMICOLON       reduce using rule 51 (returnstat -> RETURN returnstat1 .)


state 76

    (52) returnstat1 -> IDENT .
    (123) factor -> IDENT . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 52 (returnstat1 -> IDENT .)
    SEMICOLON       reduce using rule 52 (returnstat1 -> IDENT .)
    LBRACKET        shift and go to state 56
    MULTIPLY        reduce using rule 127 (empty -> .)
    DIVIDE          reduce using rule 127 (empty -> .)
    REM             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    int_constant    reduce using rule 127 (empty -> .)
    float_constant  reduce using rule 127 (empty -> .)
    string_constant reduce using rule 127 (empty -> .)
    null_constant   reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    LPAREN          reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GE              reduce using rule 127 (empty -> .)
    LE              reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)

  ! SEMICOLON       [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 147
    empty                          shift and go to state 57

state 77

    (53) returnstat1 -> expression .

    SEMICOLON       reduce using rule 53 (returnstat1 -> expression .)


state 78

    (54) returnstat1 -> empty .

    SEMICOLON       reduce using rule 54 (returnstat1 -> empty .)


state 79

    (55) ifstat -> IF LPAREN . expression RPAREN statement ifstat1
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 149
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 80

    (58) forstat -> FOR LPAREN . forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (59) forstat1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (60) forstat1 -> . empty
    (127) empty -> .

    IDENT           shift and go to state 151
    SEMICOLON       reduce using rule 127 (empty -> .)

    forstat1                       shift and go to state 150
    empty                          shift and go to state 152

state 81

    (63) whilestat -> WHILE LPAREN . expression RPAREN statement
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 153
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 82

    (7) funcdef -> DEF IDENT . LPAREN paramlist RPAREN LBRACE statelist RBRACE

    LPAREN          shift and go to state 154


state 83

    (74) statelist -> LBRACE statelist . RBRACE statelist1

    RBRACE          shift and go to state 155


state 84

    (27) statement -> LBRACE statelist RBRACE .

    $end            reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    ELSE            reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    INT             reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    FLOAT           reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    STRING          reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    IDENT           reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    PRINT           reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    READ            reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    RETURN          reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    IF              reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    FOR             reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    WHILE           reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    LBRACE          reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    BREAK           reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    SEMICOLON       reduce using rule 27 (statement -> LBRACE statelist RBRACE .)
    RBRACE          reduce using rule 27 (statement -> LBRACE statelist RBRACE .)


state 85

    (64) statelist -> INT listdcl . IDENT vardecl1 SEMICOLON statelist1

    IDENT           shift and go to state 156


state 86

    (17) listdcl -> LBRACKET . RBRACKET listdcl

    RBRACKET        shift and go to state 157


state 87

    (18) listdcl -> empty .

    IDENT           reduce using rule 18 (listdcl -> empty .)


state 88

    (67) statelist -> IDENT lvalue1 . atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (37) atribstat1 -> . LBRACKET numexpression RBRACKET atribstat1
    (38) atribstat1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 119
    ASSIGN          reduce using rule 127 (empty -> .)

    atribstat1                     shift and go to state 158
    empty                          shift and go to state 120

state 89

    (77) statelist -> IDENT LPAREN . paramlistcall RPAREN SEMICOLON statelist1
    (43) paramlistcall -> . factor paramlistcall1 paramlistcall2
    (44) paramlistcall -> . empty
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN
    (127) empty -> .

    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73
    RPAREN          reduce using rule 127 (empty -> .)

    paramlistcall                  shift and go to state 159
    factor                         shift and go to state 122
    empty                          shift and go to state 123

state 90

    (90) statelist1 -> SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 160
    empty                          shift and go to state 104

state 91

    (76) statelist -> SEMICOLON statelist1 .

    RBRACE          reduce using rule 76 (statelist -> SEMICOLON statelist1 .)


state 92

    (78) statelist1 -> INT . listdcl IDENT vardecl1 SEMICOLON statelist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 161
    empty                          shift and go to state 87

state 93

    (81) statelist1 -> IDENT . lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (91) statelist1 -> IDENT . LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 163
    LBRACKET        shift and go to state 56
    ASSIGN          reduce using rule 127 (empty -> .)

  ! LBRACKET        [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 162
    empty                          shift and go to state 57

state 94

    (79) statelist1 -> FLOAT . listdcl IDENT vardecl1 SEMICOLON statelist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 164
    empty                          shift and go to state 87

state 95

    (80) statelist1 -> STRING . listdcl IDENT vardecl1 SEMICOLON statelist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 165
    empty                          shift and go to state 87

state 96

    (82) statelist1 -> PRINT . expression SEMICOLON statelist1
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 166
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 97

    (83) statelist1 -> READ . IDENT lvalue1 SEMICOLON statelist1

    IDENT           shift and go to state 167


state 98

    (84) statelist1 -> RETURN . returnstat1 SEMICOLON statelist1
    (52) returnstat1 -> . IDENT
    (53) returnstat1 -> . expression
    (54) returnstat1 -> . empty
    (96) expression -> . numexpression expression1
    (127) empty -> .
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    IDENT           shift and go to state 76
    SEMICOLON       reduce using rule 127 (empty -> .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    LPAREN          shift and go to state 73

    returnstat1                    shift and go to state 168
    expression                     shift and go to state 77
    empty                          shift and go to state 78
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 99

    (85) statelist1 -> IF . LPAREN expression RPAREN statement ifstat1 statelist1

    LPAREN          shift and go to state 169


state 100

    (86) statelist1 -> FOR . LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    LPAREN          shift and go to state 170


state 101

    (87) statelist1 -> WHILE . LPAREN expression RPAREN statement statelist1

    LPAREN          shift and go to state 171


state 102

    (88) statelist1 -> LBRACE . statelist RBRACE statelist1
    (64) statelist -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (65) statelist -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (66) statelist -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (67) statelist -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (68) statelist -> . PRINT expression SEMICOLON statelist1
    (69) statelist -> . READ IDENT lvalue1 SEMICOLON statelist1
    (70) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (71) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (72) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (73) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (74) statelist -> . LBRACE statelist RBRACE statelist1
    (75) statelist -> . BREAK SEMICOLON statelist1
    (76) statelist -> . SEMICOLON statelist1
    (77) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 36
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 37
    PRINT           shift and go to state 41
    READ            shift and go to state 42
    RETURN          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    LBRACE          shift and go to state 34
    BREAK           shift and go to state 47
    SEMICOLON       shift and go to state 38

    statelist                      shift and go to state 172

state 103

    (89) statelist1 -> BREAK . SEMICOLON statelist1

    SEMICOLON       shift and go to state 173


state 104

    (92) statelist1 -> empty .

    RBRACE          reduce using rule 92 (statelist1 -> empty .)


state 105

    (65) statelist -> FLOAT listdcl . IDENT vardecl1 SEMICOLON statelist1

    IDENT           shift and go to state 174


state 106

    (66) statelist -> STRING listdcl . IDENT vardecl1 SEMICOLON statelist1

    IDENT           shift and go to state 175


state 107

    (68) statelist -> PRINT expression . SEMICOLON statelist1

    SEMICOLON       shift and go to state 176


state 108

    (69) statelist -> READ IDENT . lvalue1 SEMICOLON statelist1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 56
    SEMICOLON       reduce using rule 127 (empty -> .)

    lvalue1                        shift and go to state 177
    empty                          shift and go to state 57

state 109

    (70) statelist -> RETURN returnstat1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 178


state 110

    (71) statelist -> IF LPAREN . expression RPAREN statement ifstat1 statelist1
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 179
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 111

    (72) statelist -> FOR LPAREN . forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (59) forstat1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (60) forstat1 -> . empty
    (127) empty -> .

    IDENT           shift and go to state 151
    SEMICOLON       reduce using rule 127 (empty -> .)

    forstat1                       shift and go to state 180
    empty                          shift and go to state 152

state 112

    (73) statelist -> WHILE LPAREN . expression RPAREN statement statelist1
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 181
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 113

    (75) statelist -> BREAK SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 182
    empty                          shift and go to state 104

state 114

    (5) funclist1 -> DEF IDENT . LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1

    LPAREN          shift and go to state 183


state 115

    (31) vardecl -> INT IDENT vardecl1 .

    SEMICOLON       reduce using rule 31 (vardecl -> INT IDENT vardecl1 .)


state 116

    (34) vardecl1 -> LBRACKET . numexpression RBRACKET vardecl1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 184
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 117

    (35) vardecl1 -> empty .

    SEMICOLON       reduce using rule 35 (vardecl1 -> empty .)


state 118

    (36) atribstat -> IDENT lvalue1 atribstat1 . ASSIGN atribstat2

    ASSIGN          shift and go to state 185


state 119

    (37) atribstat1 -> LBRACKET . numexpression RBRACKET atribstat1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 186
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 120

    (38) atribstat1 -> empty .

    ASSIGN          reduce using rule 38 (atribstat1 -> empty .)


state 121

    (42) funccall -> IDENT LPAREN paramlistcall . RPAREN

    RPAREN          shift and go to state 187


state 122

    (43) paramlistcall -> factor . paramlistcall1 paramlistcall2
    (45) paramlistcall1 -> . LBRACKET numexpression RBRACKET paramlistcall1
    (46) paramlistcall1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 189
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    paramlistcall1                 shift and go to state 188
    empty                          shift and go to state 190

state 123

    (44) paramlistcall -> empty .

    RPAREN          reduce using rule 44 (paramlistcall -> empty .)


state 124

    (125) lvalue1 -> LBRACKET numexpression . RBRACKET lvalue1

    RBRACKET        shift and go to state 191


state 125

    (32) vardecl -> FLOAT IDENT vardecl1 .

    SEMICOLON       reduce using rule 32 (vardecl -> FLOAT IDENT vardecl1 .)


state 126

    (33) vardecl -> STRING IDENT vardecl1 .

    SEMICOLON       reduce using rule 33 (vardecl -> STRING IDENT vardecl1 .)


state 127

    (96) expression -> numexpression expression1 .

    SEMICOLON       reduce using rule 96 (expression -> numexpression expression1 .)
    RPAREN          reduce using rule 96 (expression -> numexpression expression1 .)


state 128

    (97) expression1 -> compoperator . numexpression
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 192
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 129

    (98) expression1 -> empty .

    SEMICOLON       reduce using rule 98 (expression1 -> empty .)
    RPAREN          reduce using rule 98 (expression1 -> empty .)


state 130

    (99) compoperator -> GT .

    PLUS            reduce using rule 99 (compoperator -> GT .)
    MINUS           reduce using rule 99 (compoperator -> GT .)
    int_constant    reduce using rule 99 (compoperator -> GT .)
    float_constant  reduce using rule 99 (compoperator -> GT .)
    string_constant reduce using rule 99 (compoperator -> GT .)
    null_constant   reduce using rule 99 (compoperator -> GT .)
    IDENT           reduce using rule 99 (compoperator -> GT .)
    LPAREN          reduce using rule 99 (compoperator -> GT .)


state 131

    (100) compoperator -> LT .

    PLUS            reduce using rule 100 (compoperator -> LT .)
    MINUS           reduce using rule 100 (compoperator -> LT .)
    int_constant    reduce using rule 100 (compoperator -> LT .)
    float_constant  reduce using rule 100 (compoperator -> LT .)
    string_constant reduce using rule 100 (compoperator -> LT .)
    null_constant   reduce using rule 100 (compoperator -> LT .)
    IDENT           reduce using rule 100 (compoperator -> LT .)
    LPAREN          reduce using rule 100 (compoperator -> LT .)


state 132

    (101) compoperator -> GE .

    PLUS            reduce using rule 101 (compoperator -> GE .)
    MINUS           reduce using rule 101 (compoperator -> GE .)
    int_constant    reduce using rule 101 (compoperator -> GE .)
    float_constant  reduce using rule 101 (compoperator -> GE .)
    string_constant reduce using rule 101 (compoperator -> GE .)
    null_constant   reduce using rule 101 (compoperator -> GE .)
    IDENT           reduce using rule 101 (compoperator -> GE .)
    LPAREN          reduce using rule 101 (compoperator -> GE .)


state 133

    (102) compoperator -> LE .

    PLUS            reduce using rule 102 (compoperator -> LE .)
    MINUS           reduce using rule 102 (compoperator -> LE .)
    int_constant    reduce using rule 102 (compoperator -> LE .)
    float_constant  reduce using rule 102 (compoperator -> LE .)
    string_constant reduce using rule 102 (compoperator -> LE .)
    null_constant   reduce using rule 102 (compoperator -> LE .)
    IDENT           reduce using rule 102 (compoperator -> LE .)
    LPAREN          reduce using rule 102 (compoperator -> LE .)


state 134

    (103) compoperator -> EQ .

    PLUS            reduce using rule 103 (compoperator -> EQ .)
    MINUS           reduce using rule 103 (compoperator -> EQ .)
    int_constant    reduce using rule 103 (compoperator -> EQ .)
    float_constant  reduce using rule 103 (compoperator -> EQ .)
    string_constant reduce using rule 103 (compoperator -> EQ .)
    null_constant   reduce using rule 103 (compoperator -> EQ .)
    IDENT           reduce using rule 103 (compoperator -> EQ .)
    LPAREN          reduce using rule 103 (compoperator -> EQ .)


state 135

    (104) compoperator -> NEQ .

    PLUS            reduce using rule 104 (compoperator -> NEQ .)
    MINUS           reduce using rule 104 (compoperator -> NEQ .)
    int_constant    reduce using rule 104 (compoperator -> NEQ .)
    float_constant  reduce using rule 104 (compoperator -> NEQ .)
    string_constant reduce using rule 104 (compoperator -> NEQ .)
    null_constant   reduce using rule 104 (compoperator -> NEQ .)
    IDENT           reduce using rule 104 (compoperator -> NEQ .)
    LPAREN          reduce using rule 104 (compoperator -> NEQ .)


state 136

    (107) numexpression1 -> term .

    GT              reduce using rule 107 (numexpression1 -> term .)
    LT              reduce using rule 107 (numexpression1 -> term .)
    GE              reduce using rule 107 (numexpression1 -> term .)
    LE              reduce using rule 107 (numexpression1 -> term .)
    EQ              reduce using rule 107 (numexpression1 -> term .)
    NEQ             reduce using rule 107 (numexpression1 -> term .)
    SEMICOLON       reduce using rule 107 (numexpression1 -> term .)
    RBRACKET        reduce using rule 107 (numexpression1 -> term .)
    RPAREN          reduce using rule 107 (numexpression1 -> term .)


state 137

    (105) numexpression -> term numexpression1 .

    GT              reduce using rule 105 (numexpression -> term numexpression1 .)
    LT              reduce using rule 105 (numexpression -> term numexpression1 .)
    GE              reduce using rule 105 (numexpression -> term numexpression1 .)
    LE              reduce using rule 105 (numexpression -> term numexpression1 .)
    EQ              reduce using rule 105 (numexpression -> term numexpression1 .)
    NEQ             reduce using rule 105 (numexpression -> term numexpression1 .)
    SEMICOLON       reduce using rule 105 (numexpression -> term numexpression1 .)
    RBRACKET        reduce using rule 105 (numexpression -> term numexpression1 .)
    RPAREN          reduce using rule 105 (numexpression -> term numexpression1 .)


state 138

    (106) numexpression1 -> addsub . term
    (117) unaryexpr -> addsub . factor
    (111) term -> . unaryexpr term1
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS

    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    addsub                         shift and go to state 64
    term                           shift and go to state 193
    factor                         shift and go to state 194
    unaryexpr                      shift and go to state 63

state 139

    (108) numexpression1 -> empty .

    GT              reduce using rule 108 (numexpression1 -> empty .)
    LT              reduce using rule 108 (numexpression1 -> empty .)
    GE              reduce using rule 108 (numexpression1 -> empty .)
    LE              reduce using rule 108 (numexpression1 -> empty .)
    EQ              reduce using rule 108 (numexpression1 -> empty .)
    NEQ             reduce using rule 108 (numexpression1 -> empty .)
    SEMICOLON       reduce using rule 108 (numexpression1 -> empty .)
    RBRACKET        reduce using rule 108 (numexpression1 -> empty .)
    RPAREN          reduce using rule 108 (numexpression1 -> empty .)


state 140

    (111) term -> unaryexpr term1 .

    PLUS            reduce using rule 111 (term -> unaryexpr term1 .)
    MINUS           reduce using rule 111 (term -> unaryexpr term1 .)
    int_constant    reduce using rule 111 (term -> unaryexpr term1 .)
    float_constant  reduce using rule 111 (term -> unaryexpr term1 .)
    string_constant reduce using rule 111 (term -> unaryexpr term1 .)
    null_constant   reduce using rule 111 (term -> unaryexpr term1 .)
    IDENT           reduce using rule 111 (term -> unaryexpr term1 .)
    LPAREN          reduce using rule 111 (term -> unaryexpr term1 .)
    GT              reduce using rule 111 (term -> unaryexpr term1 .)
    LT              reduce using rule 111 (term -> unaryexpr term1 .)
    GE              reduce using rule 111 (term -> unaryexpr term1 .)
    LE              reduce using rule 111 (term -> unaryexpr term1 .)
    EQ              reduce using rule 111 (term -> unaryexpr term1 .)
    NEQ             reduce using rule 111 (term -> unaryexpr term1 .)
    SEMICOLON       reduce using rule 111 (term -> unaryexpr term1 .)
    RBRACKET        reduce using rule 111 (term -> unaryexpr term1 .)
    RPAREN          reduce using rule 111 (term -> unaryexpr term1 .)


state 141

    (112) term1 -> multdiv . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    unaryexpr                      shift and go to state 195
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 142

    (113) term1 -> empty .

    PLUS            reduce using rule 113 (term1 -> empty .)
    MINUS           reduce using rule 113 (term1 -> empty .)
    int_constant    reduce using rule 113 (term1 -> empty .)
    float_constant  reduce using rule 113 (term1 -> empty .)
    string_constant reduce using rule 113 (term1 -> empty .)
    null_constant   reduce using rule 113 (term1 -> empty .)
    IDENT           reduce using rule 113 (term1 -> empty .)
    LPAREN          reduce using rule 113 (term1 -> empty .)
    GT              reduce using rule 113 (term1 -> empty .)
    LT              reduce using rule 113 (term1 -> empty .)
    GE              reduce using rule 113 (term1 -> empty .)
    LE              reduce using rule 113 (term1 -> empty .)
    EQ              reduce using rule 113 (term1 -> empty .)
    NEQ             reduce using rule 113 (term1 -> empty .)
    SEMICOLON       reduce using rule 113 (term1 -> empty .)
    RBRACKET        reduce using rule 113 (term1 -> empty .)
    RPAREN          reduce using rule 113 (term1 -> empty .)


state 143

    (114) multdiv -> MULTIPLY .

    PLUS            reduce using rule 114 (multdiv -> MULTIPLY .)
    MINUS           reduce using rule 114 (multdiv -> MULTIPLY .)
    int_constant    reduce using rule 114 (multdiv -> MULTIPLY .)
    float_constant  reduce using rule 114 (multdiv -> MULTIPLY .)
    string_constant reduce using rule 114 (multdiv -> MULTIPLY .)
    null_constant   reduce using rule 114 (multdiv -> MULTIPLY .)
    IDENT           reduce using rule 114 (multdiv -> MULTIPLY .)
    LPAREN          reduce using rule 114 (multdiv -> MULTIPLY .)


state 144

    (115) multdiv -> DIVIDE .

    PLUS            reduce using rule 115 (multdiv -> DIVIDE .)
    MINUS           reduce using rule 115 (multdiv -> DIVIDE .)
    int_constant    reduce using rule 115 (multdiv -> DIVIDE .)
    float_constant  reduce using rule 115 (multdiv -> DIVIDE .)
    string_constant reduce using rule 115 (multdiv -> DIVIDE .)
    null_constant   reduce using rule 115 (multdiv -> DIVIDE .)
    IDENT           reduce using rule 115 (multdiv -> DIVIDE .)
    LPAREN          reduce using rule 115 (multdiv -> DIVIDE .)


state 145

    (116) multdiv -> REM .

    PLUS            reduce using rule 116 (multdiv -> REM .)
    MINUS           reduce using rule 116 (multdiv -> REM .)
    int_constant    reduce using rule 116 (multdiv -> REM .)
    float_constant  reduce using rule 116 (multdiv -> REM .)
    string_constant reduce using rule 116 (multdiv -> REM .)
    null_constant   reduce using rule 116 (multdiv -> REM .)
    IDENT           reduce using rule 116 (multdiv -> REM .)
    LPAREN          reduce using rule 116 (multdiv -> REM .)


state 146

    (117) unaryexpr -> addsub factor .

    MULTIPLY        reduce using rule 117 (unaryexpr -> addsub factor .)
    DIVIDE          reduce using rule 117 (unaryexpr -> addsub factor .)
    REM             reduce using rule 117 (unaryexpr -> addsub factor .)
    PLUS            reduce using rule 117 (unaryexpr -> addsub factor .)
    MINUS           reduce using rule 117 (unaryexpr -> addsub factor .)
    int_constant    reduce using rule 117 (unaryexpr -> addsub factor .)
    float_constant  reduce using rule 117 (unaryexpr -> addsub factor .)
    string_constant reduce using rule 117 (unaryexpr -> addsub factor .)
    null_constant   reduce using rule 117 (unaryexpr -> addsub factor .)
    IDENT           reduce using rule 117 (unaryexpr -> addsub factor .)
    LPAREN          reduce using rule 117 (unaryexpr -> addsub factor .)
    GT              reduce using rule 117 (unaryexpr -> addsub factor .)
    LT              reduce using rule 117 (unaryexpr -> addsub factor .)
    GE              reduce using rule 117 (unaryexpr -> addsub factor .)
    LE              reduce using rule 117 (unaryexpr -> addsub factor .)
    EQ              reduce using rule 117 (unaryexpr -> addsub factor .)
    NEQ             reduce using rule 117 (unaryexpr -> addsub factor .)
    SEMICOLON       reduce using rule 117 (unaryexpr -> addsub factor .)
    RBRACKET        reduce using rule 117 (unaryexpr -> addsub factor .)
    RPAREN          reduce using rule 117 (unaryexpr -> addsub factor .)


state 147

    (123) factor -> IDENT lvalue1 .

    MULTIPLY        reduce using rule 123 (factor -> IDENT lvalue1 .)
    DIVIDE          reduce using rule 123 (factor -> IDENT lvalue1 .)
    REM             reduce using rule 123 (factor -> IDENT lvalue1 .)
    PLUS            reduce using rule 123 (factor -> IDENT lvalue1 .)
    MINUS           reduce using rule 123 (factor -> IDENT lvalue1 .)
    int_constant    reduce using rule 123 (factor -> IDENT lvalue1 .)
    float_constant  reduce using rule 123 (factor -> IDENT lvalue1 .)
    string_constant reduce using rule 123 (factor -> IDENT lvalue1 .)
    null_constant   reduce using rule 123 (factor -> IDENT lvalue1 .)
    IDENT           reduce using rule 123 (factor -> IDENT lvalue1 .)
    LPAREN          reduce using rule 123 (factor -> IDENT lvalue1 .)
    GT              reduce using rule 123 (factor -> IDENT lvalue1 .)
    LT              reduce using rule 123 (factor -> IDENT lvalue1 .)
    GE              reduce using rule 123 (factor -> IDENT lvalue1 .)
    LE              reduce using rule 123 (factor -> IDENT lvalue1 .)
    EQ              reduce using rule 123 (factor -> IDENT lvalue1 .)
    NEQ             reduce using rule 123 (factor -> IDENT lvalue1 .)
    SEMICOLON       reduce using rule 123 (factor -> IDENT lvalue1 .)
    LBRACKET        reduce using rule 123 (factor -> IDENT lvalue1 .)
    COMMA           reduce using rule 123 (factor -> IDENT lvalue1 .)
    RPAREN          reduce using rule 123 (factor -> IDENT lvalue1 .)
    RBRACKET        reduce using rule 123 (factor -> IDENT lvalue1 .)


state 148

    (124) factor -> LPAREN numexpression . RPAREN

    RPAREN          shift and go to state 196


state 149

    (55) ifstat -> IF LPAREN expression . RPAREN statement ifstat1

    RPAREN          shift and go to state 197


state 150

    (58) forstat -> FOR LPAREN forstat1 . SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement

    SEMICOLON       shift and go to state 198


state 151

    (59) forstat1 -> IDENT . lvalue1 atribstat1 ASSIGN atribstat2
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 56
    ASSIGN          reduce using rule 127 (empty -> .)

  ! LBRACKET        [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 199
    empty                          shift and go to state 57

state 152

    (60) forstat1 -> empty .

    SEMICOLON       reduce using rule 60 (forstat1 -> empty .)
    RPAREN          reduce using rule 60 (forstat1 -> empty .)


state 153

    (63) whilestat -> WHILE LPAREN expression . RPAREN statement

    RPAREN          shift and go to state 200


state 154

    (7) funcdef -> DEF IDENT LPAREN . paramlist RPAREN LBRACE statelist RBRACE
    (11) paramlist -> . STRING listdcl IDENT paramlist1
    (12) paramlist -> . FLOAT listdcl IDENT paramlist1
    (13) paramlist -> . INT listdcl IDENT paramlist1
    (14) paramlist -> . empty
    (127) empty -> .

    STRING          shift and go to state 202
    FLOAT           shift and go to state 203
    INT             shift and go to state 204
    RPAREN          reduce using rule 127 (empty -> .)

    paramlist                      shift and go to state 201
    empty                          shift and go to state 205

state 155

    (74) statelist -> LBRACE statelist RBRACE . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 206
    empty                          shift and go to state 104

state 156

    (64) statelist -> INT listdcl IDENT . vardecl1 SEMICOLON statelist1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 207
    empty                          shift and go to state 117

state 157

    (17) listdcl -> LBRACKET RBRACKET . listdcl
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 208
    empty                          shift and go to state 87

state 158

    (67) statelist -> IDENT lvalue1 atribstat1 . ASSIGN atribstat2 SEMICOLON statelist1

    ASSIGN          shift and go to state 209


state 159

    (77) statelist -> IDENT LPAREN paramlistcall . RPAREN SEMICOLON statelist1

    RPAREN          shift and go to state 210


state 160

    (90) statelist1 -> SEMICOLON statelist1 .

    RBRACE          reduce using rule 90 (statelist1 -> SEMICOLON statelist1 .)


state 161

    (78) statelist1 -> INT listdcl . IDENT vardecl1 SEMICOLON statelist1

    IDENT           shift and go to state 211


state 162

    (81) statelist1 -> IDENT lvalue1 . atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (37) atribstat1 -> . LBRACKET numexpression RBRACKET atribstat1
    (38) atribstat1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 119
    ASSIGN          reduce using rule 127 (empty -> .)

    atribstat1                     shift and go to state 212
    empty                          shift and go to state 120

state 163

    (91) statelist1 -> IDENT LPAREN . paramlistcall RPAREN SEMICOLON statelist1
    (43) paramlistcall -> . factor paramlistcall1 paramlistcall2
    (44) paramlistcall -> . empty
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN
    (127) empty -> .

    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73
    RPAREN          reduce using rule 127 (empty -> .)

    paramlistcall                  shift and go to state 213
    factor                         shift and go to state 122
    empty                          shift and go to state 123

state 164

    (79) statelist1 -> FLOAT listdcl . IDENT vardecl1 SEMICOLON statelist1

    IDENT           shift and go to state 214


state 165

    (80) statelist1 -> STRING listdcl . IDENT vardecl1 SEMICOLON statelist1

    IDENT           shift and go to state 215


state 166

    (82) statelist1 -> PRINT expression . SEMICOLON statelist1

    SEMICOLON       shift and go to state 216


state 167

    (83) statelist1 -> READ IDENT . lvalue1 SEMICOLON statelist1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 56
    SEMICOLON       reduce using rule 127 (empty -> .)

    lvalue1                        shift and go to state 217
    empty                          shift and go to state 57

state 168

    (84) statelist1 -> RETURN returnstat1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 218


state 169

    (85) statelist1 -> IF LPAREN . expression RPAREN statement ifstat1 statelist1
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 219
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 170

    (86) statelist1 -> FOR LPAREN . forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (59) forstat1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (60) forstat1 -> . empty
    (127) empty -> .

    IDENT           shift and go to state 151
    SEMICOLON       reduce using rule 127 (empty -> .)

    forstat1                       shift and go to state 220
    empty                          shift and go to state 152

state 171

    (87) statelist1 -> WHILE LPAREN . expression RPAREN statement statelist1
    (96) expression -> . numexpression expression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    expression                     shift and go to state 221
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 172

    (88) statelist1 -> LBRACE statelist . RBRACE statelist1

    RBRACE          shift and go to state 222


state 173

    (89) statelist1 -> BREAK SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 223
    empty                          shift and go to state 104

state 174

    (65) statelist -> FLOAT listdcl IDENT . vardecl1 SEMICOLON statelist1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 224
    empty                          shift and go to state 117

state 175

    (66) statelist -> STRING listdcl IDENT . vardecl1 SEMICOLON statelist1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 225
    empty                          shift and go to state 117

state 176

    (68) statelist -> PRINT expression SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 226
    empty                          shift and go to state 104

state 177

    (69) statelist -> READ IDENT lvalue1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 227


state 178

    (70) statelist -> RETURN returnstat1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 228
    empty                          shift and go to state 104

state 179

    (71) statelist -> IF LPAREN expression . RPAREN statement ifstat1 statelist1

    RPAREN          shift and go to state 229


state 180

    (72) statelist -> FOR LPAREN forstat1 . SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 230


state 181

    (73) statelist -> WHILE LPAREN expression . RPAREN statement statelist1

    RPAREN          shift and go to state 231


state 182

    (75) statelist -> BREAK SEMICOLON statelist1 .

    RBRACE          reduce using rule 75 (statelist -> BREAK SEMICOLON statelist1 .)


state 183

    (5) funclist1 -> DEF IDENT LPAREN . paramlist RPAREN LBRACE statelist RBRACE funclist1
    (11) paramlist -> . STRING listdcl IDENT paramlist1
    (12) paramlist -> . FLOAT listdcl IDENT paramlist1
    (13) paramlist -> . INT listdcl IDENT paramlist1
    (14) paramlist -> . empty
    (127) empty -> .

    STRING          shift and go to state 202
    FLOAT           shift and go to state 203
    INT             shift and go to state 204
    RPAREN          reduce using rule 127 (empty -> .)

    paramlist                      shift and go to state 232
    empty                          shift and go to state 205

state 184

    (34) vardecl1 -> LBRACKET numexpression . RBRACKET vardecl1

    RBRACKET        shift and go to state 233


state 185

    (36) atribstat -> IDENT lvalue1 atribstat1 ASSIGN . atribstat2
    (39) atribstat2 -> . expression
    (40) atribstat2 -> . allocexpression
    (41) atribstat2 -> . funccall
    (96) expression -> . numexpression expression1
    (93) allocexpression -> . NEW types LBRACKET numexpression RBRACKET allocexpression1
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 239
    IDENT           shift and go to state 234
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    LPAREN          shift and go to state 73

    atribstat2                     shift and go to state 235
    expression                     shift and go to state 236
    allocexpression                shift and go to state 237
    funccall                       shift and go to state 238
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 186

    (37) atribstat1 -> LBRACKET numexpression . RBRACKET atribstat1

    RBRACKET        shift and go to state 240


state 187

    (42) funccall -> IDENT LPAREN paramlistcall RPAREN .

    SEMICOLON       reduce using rule 42 (funccall -> IDENT LPAREN paramlistcall RPAREN .)
    RPAREN          reduce using rule 42 (funccall -> IDENT LPAREN paramlistcall RPAREN .)


state 188

    (43) paramlistcall -> factor paramlistcall1 . paramlistcall2
    (47) paramlistcall2 -> . COMMA paramlistcall
    (48) paramlistcall2 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 242
    RPAREN          reduce using rule 127 (empty -> .)

    paramlistcall2                 shift and go to state 241
    empty                          shift and go to state 243

state 189

    (45) paramlistcall1 -> LBRACKET . numexpression RBRACKET paramlistcall1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 244
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 190

    (46) paramlistcall1 -> empty .

    COMMA           reduce using rule 46 (paramlistcall1 -> empty .)
    RPAREN          reduce using rule 46 (paramlistcall1 -> empty .)


state 191

    (125) lvalue1 -> LBRACKET numexpression RBRACKET . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACKET        shift and go to state 56
    ASSIGN          reduce using rule 127 (empty -> .)
    MULTIPLY        reduce using rule 127 (empty -> .)
    DIVIDE          reduce using rule 127 (empty -> .)
    REM             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    int_constant    reduce using rule 127 (empty -> .)
    float_constant  reduce using rule 127 (empty -> .)
    string_constant reduce using rule 127 (empty -> .)
    null_constant   reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    LPAREN          reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GE              reduce using rule 127 (empty -> .)
    LE              reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)
    RBRACKET        reduce using rule 127 (empty -> .)

  ! LBRACKET        [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 245
    empty                          shift and go to state 57

state 192

    (97) expression1 -> compoperator numexpression .

    SEMICOLON       reduce using rule 97 (expression1 -> compoperator numexpression .)
    RPAREN          reduce using rule 97 (expression1 -> compoperator numexpression .)


state 193

    (106) numexpression1 -> addsub term .

    GT              reduce using rule 106 (numexpression1 -> addsub term .)
    LT              reduce using rule 106 (numexpression1 -> addsub term .)
    GE              reduce using rule 106 (numexpression1 -> addsub term .)
    LE              reduce using rule 106 (numexpression1 -> addsub term .)
    EQ              reduce using rule 106 (numexpression1 -> addsub term .)
    NEQ             reduce using rule 106 (numexpression1 -> addsub term .)
    SEMICOLON       reduce using rule 106 (numexpression1 -> addsub term .)
    RBRACKET        reduce using rule 106 (numexpression1 -> addsub term .)
    RPAREN          reduce using rule 106 (numexpression1 -> addsub term .)


state 194

    (117) unaryexpr -> addsub factor .
    (118) unaryexpr -> factor .

  ! reduce/reduce conflict for MULTIPLY resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for REM resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for GT resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for LT resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for GE resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for LE resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for EQ resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for NEQ resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 117 (unaryexpr -> addsub factor .)
  ! reduce/reduce conflict for RPAREN resolved using rule 117 (unaryexpr -> addsub factor .)
    MULTIPLY        reduce using rule 117 (unaryexpr -> addsub factor .)
    DIVIDE          reduce using rule 117 (unaryexpr -> addsub factor .)
    REM             reduce using rule 117 (unaryexpr -> addsub factor .)
    GT              reduce using rule 117 (unaryexpr -> addsub factor .)
    LT              reduce using rule 117 (unaryexpr -> addsub factor .)
    GE              reduce using rule 117 (unaryexpr -> addsub factor .)
    LE              reduce using rule 117 (unaryexpr -> addsub factor .)
    EQ              reduce using rule 117 (unaryexpr -> addsub factor .)
    NEQ             reduce using rule 117 (unaryexpr -> addsub factor .)
    SEMICOLON       reduce using rule 117 (unaryexpr -> addsub factor .)
    RBRACKET        reduce using rule 117 (unaryexpr -> addsub factor .)
    RPAREN          reduce using rule 117 (unaryexpr -> addsub factor .)

  ! MULTIPLY        [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! DIVIDE          [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! REM             [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! GT              [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! LT              [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! GE              [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! LE              [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! EQ              [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! NEQ             [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! SEMICOLON       [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! RBRACKET        [ reduce using rule 118 (unaryexpr -> factor .) ]
  ! RPAREN          [ reduce using rule 118 (unaryexpr -> factor .) ]


state 195

    (112) term1 -> multdiv unaryexpr . term1
    (112) term1 -> . multdiv unaryexpr term1
    (113) term1 -> . empty
    (114) multdiv -> . MULTIPLY
    (115) multdiv -> . DIVIDE
    (116) multdiv -> . REM
    (127) empty -> .

    MULTIPLY        shift and go to state 143
    DIVIDE          shift and go to state 144
    REM             shift and go to state 145
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    int_constant    reduce using rule 127 (empty -> .)
    float_constant  reduce using rule 127 (empty -> .)
    string_constant reduce using rule 127 (empty -> .)
    null_constant   reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    LPAREN          reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GE              reduce using rule 127 (empty -> .)
    LE              reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    RBRACKET        reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    multdiv                        shift and go to state 141
    term1                          shift and go to state 246
    empty                          shift and go to state 142

state 196

    (124) factor -> LPAREN numexpression RPAREN .

    MULTIPLY        reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    DIVIDE          reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    REM             reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    PLUS            reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    MINUS           reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    int_constant    reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    float_constant  reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    string_constant reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    null_constant   reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    IDENT           reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    LPAREN          reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    GT              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    LT              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    GE              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    LE              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    EQ              reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    NEQ             reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    SEMICOLON       reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    LBRACKET        reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    COMMA           reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    RPAREN          reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)
    RBRACKET        reduce using rule 124 (factor -> LPAREN numexpression RPAREN .)


state 197

    (55) ifstat -> IF LPAREN expression RPAREN . statement ifstat1
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 247
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 198

    (58) forstat -> FOR LPAREN forstat1 SEMICOLON . forstat2 SEMICOLON forstat1 RPAREN statement
    (61) forstat2 -> . expression
    (62) forstat2 -> . empty
    (96) expression -> . numexpression expression1
    (127) empty -> .
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 127 (empty -> .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    forstat2                       shift and go to state 248
    expression                     shift and go to state 249
    empty                          shift and go to state 250
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 199

    (59) forstat1 -> IDENT lvalue1 . atribstat1 ASSIGN atribstat2
    (37) atribstat1 -> . LBRACKET numexpression RBRACKET atribstat1
    (38) atribstat1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 119
    ASSIGN          reduce using rule 127 (empty -> .)

    atribstat1                     shift and go to state 251
    empty                          shift and go to state 120

state 200

    (63) whilestat -> WHILE LPAREN expression RPAREN . statement
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 252
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 201

    (7) funcdef -> DEF IDENT LPAREN paramlist . RPAREN LBRACE statelist RBRACE

    RPAREN          shift and go to state 253


state 202

    (11) paramlist -> STRING . listdcl IDENT paramlist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 254
    empty                          shift and go to state 87

state 203

    (12) paramlist -> FLOAT . listdcl IDENT paramlist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 255
    empty                          shift and go to state 87

state 204

    (13) paramlist -> INT . listdcl IDENT paramlist1
    (17) listdcl -> . LBRACKET RBRACKET listdcl
    (18) listdcl -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 86
    IDENT           reduce using rule 127 (empty -> .)

    listdcl                        shift and go to state 256
    empty                          shift and go to state 87

state 205

    (14) paramlist -> empty .

    RPAREN          reduce using rule 14 (paramlist -> empty .)


state 206

    (74) statelist -> LBRACE statelist RBRACE statelist1 .

    RBRACE          reduce using rule 74 (statelist -> LBRACE statelist RBRACE statelist1 .)


state 207

    (64) statelist -> INT listdcl IDENT vardecl1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 257


state 208

    (17) listdcl -> LBRACKET RBRACKET listdcl .

    IDENT           reduce using rule 17 (listdcl -> LBRACKET RBRACKET listdcl .)


state 209

    (67) statelist -> IDENT lvalue1 atribstat1 ASSIGN . atribstat2 SEMICOLON statelist1
    (39) atribstat2 -> . expression
    (40) atribstat2 -> . allocexpression
    (41) atribstat2 -> . funccall
    (96) expression -> . numexpression expression1
    (93) allocexpression -> . NEW types LBRACKET numexpression RBRACKET allocexpression1
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 239
    IDENT           shift and go to state 234
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    LPAREN          shift and go to state 73

    atribstat2                     shift and go to state 258
    expression                     shift and go to state 236
    allocexpression                shift and go to state 237
    funccall                       shift and go to state 238
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 210

    (77) statelist -> IDENT LPAREN paramlistcall RPAREN . SEMICOLON statelist1

    SEMICOLON       shift and go to state 259


state 211

    (78) statelist1 -> INT listdcl IDENT . vardecl1 SEMICOLON statelist1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 260
    empty                          shift and go to state 117

state 212

    (81) statelist1 -> IDENT lvalue1 atribstat1 . ASSIGN atribstat2 SEMICOLON statelist1

    ASSIGN          shift and go to state 261


state 213

    (91) statelist1 -> IDENT LPAREN paramlistcall . RPAREN SEMICOLON statelist1

    RPAREN          shift and go to state 262


state 214

    (79) statelist1 -> FLOAT listdcl IDENT . vardecl1 SEMICOLON statelist1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 263
    empty                          shift and go to state 117

state 215

    (80) statelist1 -> STRING listdcl IDENT . vardecl1 SEMICOLON statelist1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 264
    empty                          shift and go to state 117

state 216

    (82) statelist1 -> PRINT expression SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 265
    empty                          shift and go to state 104

state 217

    (83) statelist1 -> READ IDENT lvalue1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 266


state 218

    (84) statelist1 -> RETURN returnstat1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 267
    empty                          shift and go to state 104

state 219

    (85) statelist1 -> IF LPAREN expression . RPAREN statement ifstat1 statelist1

    RPAREN          shift and go to state 268


state 220

    (86) statelist1 -> FOR LPAREN forstat1 . SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 269


state 221

    (87) statelist1 -> WHILE LPAREN expression . RPAREN statement statelist1

    RPAREN          shift and go to state 270


state 222

    (88) statelist1 -> LBRACE statelist RBRACE . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 271
    empty                          shift and go to state 104

state 223

    (89) statelist1 -> BREAK SEMICOLON statelist1 .

    RBRACE          reduce using rule 89 (statelist1 -> BREAK SEMICOLON statelist1 .)


state 224

    (65) statelist -> FLOAT listdcl IDENT vardecl1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 272


state 225

    (66) statelist -> STRING listdcl IDENT vardecl1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 273


state 226

    (68) statelist -> PRINT expression SEMICOLON statelist1 .

    RBRACE          reduce using rule 68 (statelist -> PRINT expression SEMICOLON statelist1 .)


state 227

    (69) statelist -> READ IDENT lvalue1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 274
    empty                          shift and go to state 104

state 228

    (70) statelist -> RETURN returnstat1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 70 (statelist -> RETURN returnstat1 SEMICOLON statelist1 .)


state 229

    (71) statelist -> IF LPAREN expression RPAREN . statement ifstat1 statelist1
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 275
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 230

    (72) statelist -> FOR LPAREN forstat1 SEMICOLON . forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (61) forstat2 -> . expression
    (62) forstat2 -> . empty
    (96) expression -> . numexpression expression1
    (127) empty -> .
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 127 (empty -> .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    forstat2                       shift and go to state 276
    expression                     shift and go to state 249
    empty                          shift and go to state 250
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 231

    (73) statelist -> WHILE LPAREN expression RPAREN . statement statelist1
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 277
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 232

    (5) funclist1 -> DEF IDENT LPAREN paramlist . RPAREN LBRACE statelist RBRACE funclist1

    RPAREN          shift and go to state 278


state 233

    (34) vardecl1 -> LBRACKET numexpression RBRACKET . vardecl1
    (34) vardecl1 -> . LBRACKET numexpression RBRACKET vardecl1
    (35) vardecl1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 116
    SEMICOLON       reduce using rule 127 (empty -> .)

    vardecl1                       shift and go to state 279
    empty                          shift and go to state 117

state 234

    (42) funccall -> IDENT . LPAREN paramlistcall RPAREN
    (123) factor -> IDENT . lvalue1
    (125) lvalue1 -> . LBRACKET numexpression RBRACKET lvalue1
    (126) lvalue1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 55
    LBRACKET        shift and go to state 56
    MULTIPLY        reduce using rule 127 (empty -> .)
    DIVIDE          reduce using rule 127 (empty -> .)
    REM             reduce using rule 127 (empty -> .)
    PLUS            reduce using rule 127 (empty -> .)
    MINUS           reduce using rule 127 (empty -> .)
    int_constant    reduce using rule 127 (empty -> .)
    float_constant  reduce using rule 127 (empty -> .)
    string_constant reduce using rule 127 (empty -> .)
    null_constant   reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    GT              reduce using rule 127 (empty -> .)
    LT              reduce using rule 127 (empty -> .)
    GE              reduce using rule 127 (empty -> .)
    LE              reduce using rule 127 (empty -> .)
    EQ              reduce using rule 127 (empty -> .)
    NEQ             reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

  ! LPAREN          [ reduce using rule 127 (empty -> .) ]

    lvalue1                        shift and go to state 147
    empty                          shift and go to state 57

state 235

    (36) atribstat -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 .

    SEMICOLON       reduce using rule 36 (atribstat -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 .)


state 236

    (39) atribstat2 -> expression .

    SEMICOLON       reduce using rule 39 (atribstat2 -> expression .)
    RPAREN          reduce using rule 39 (atribstat2 -> expression .)


state 237

    (40) atribstat2 -> allocexpression .

    SEMICOLON       reduce using rule 40 (atribstat2 -> allocexpression .)
    RPAREN          reduce using rule 40 (atribstat2 -> allocexpression .)


state 238

    (41) atribstat2 -> funccall .

    SEMICOLON       reduce using rule 41 (atribstat2 -> funccall .)
    RPAREN          reduce using rule 41 (atribstat2 -> funccall .)


state 239

    (93) allocexpression -> NEW . types LBRACKET numexpression RBRACKET allocexpression1
    (8) types -> . INT
    (9) types -> . FLOAT
    (10) types -> . STRING

    INT             shift and go to state 281
    FLOAT           shift and go to state 282
    STRING          shift and go to state 283

    types                          shift and go to state 280

state 240

    (37) atribstat1 -> LBRACKET numexpression RBRACKET . atribstat1
    (37) atribstat1 -> . LBRACKET numexpression RBRACKET atribstat1
    (38) atribstat1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 119
    ASSIGN          reduce using rule 127 (empty -> .)

    atribstat1                     shift and go to state 284
    empty                          shift and go to state 120

state 241

    (43) paramlistcall -> factor paramlistcall1 paramlistcall2 .

    RPAREN          reduce using rule 43 (paramlistcall -> factor paramlistcall1 paramlistcall2 .)


state 242

    (47) paramlistcall2 -> COMMA . paramlistcall
    (43) paramlistcall -> . factor paramlistcall1 paramlistcall2
    (44) paramlistcall -> . empty
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN
    (127) empty -> .

    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73
    RPAREN          reduce using rule 127 (empty -> .)

    paramlistcall                  shift and go to state 285
    factor                         shift and go to state 122
    empty                          shift and go to state 123

state 243

    (48) paramlistcall2 -> empty .

    RPAREN          reduce using rule 48 (paramlistcall2 -> empty .)


state 244

    (45) paramlistcall1 -> LBRACKET numexpression . RBRACKET paramlistcall1

    RBRACKET        shift and go to state 286


state 245

    (125) lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .

    LBRACKET        reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    ASSIGN          reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    MULTIPLY        reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    DIVIDE          reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    REM             reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    PLUS            reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    MINUS           reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    int_constant    reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    float_constant  reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    string_constant reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    null_constant   reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    IDENT           reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    LPAREN          reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    GT              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    LT              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    GE              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    LE              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    EQ              reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    NEQ             reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    SEMICOLON       reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    COMMA           reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    RPAREN          reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)
    RBRACKET        reduce using rule 125 (lvalue1 -> LBRACKET numexpression RBRACKET lvalue1 .)


state 246

    (112) term1 -> multdiv unaryexpr term1 .

    PLUS            reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    MINUS           reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    int_constant    reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    float_constant  reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    string_constant reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    null_constant   reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    IDENT           reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    LPAREN          reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    GT              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    LT              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    GE              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    LE              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    EQ              reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    NEQ             reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    SEMICOLON       reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    RBRACKET        reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)
    RPAREN          reduce using rule 112 (term1 -> multdiv unaryexpr term1 .)


state 247

    (55) ifstat -> IF LPAREN expression RPAREN statement . ifstat1
    (56) ifstat1 -> . ELSE statement
    (57) ifstat1 -> . empty
    (127) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 288
    $end            reduce using rule 127 (empty -> .)
    INT             reduce using rule 127 (empty -> .)
    FLOAT           reduce using rule 127 (empty -> .)
    STRING          reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    FOR             reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    LBRACE          reduce using rule 127 (empty -> .)
    BREAK           reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    RBRACE          reduce using rule 127 (empty -> .)

  ! ELSE            [ reduce using rule 127 (empty -> .) ]

    ifstat1                        shift and go to state 287
    empty                          shift and go to state 289

state 248

    (58) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 . SEMICOLON forstat1 RPAREN statement

    SEMICOLON       shift and go to state 290


state 249

    (61) forstat2 -> expression .

    SEMICOLON       reduce using rule 61 (forstat2 -> expression .)


state 250

    (62) forstat2 -> empty .

    SEMICOLON       reduce using rule 62 (forstat2 -> empty .)


state 251

    (59) forstat1 -> IDENT lvalue1 atribstat1 . ASSIGN atribstat2

    ASSIGN          shift and go to state 291


state 252

    (63) whilestat -> WHILE LPAREN expression RPAREN statement .

    $end            reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    STRING          reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    IDENT           reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    PRINT           reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    READ            reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    SEMICOLON       reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)
    RBRACE          reduce using rule 63 (whilestat -> WHILE LPAREN expression RPAREN statement .)


state 253

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN . LBRACE statelist RBRACE

    LBRACE          shift and go to state 292


state 254

    (11) paramlist -> STRING listdcl . IDENT paramlist1

    IDENT           shift and go to state 293


state 255

    (12) paramlist -> FLOAT listdcl . IDENT paramlist1

    IDENT           shift and go to state 294


state 256

    (13) paramlist -> INT listdcl . IDENT paramlist1

    IDENT           shift and go to state 295


state 257

    (64) statelist -> INT listdcl IDENT vardecl1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 296
    empty                          shift and go to state 104

state 258

    (67) statelist -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 297


state 259

    (77) statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 298
    empty                          shift and go to state 104

state 260

    (78) statelist1 -> INT listdcl IDENT vardecl1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 299


state 261

    (81) statelist1 -> IDENT lvalue1 atribstat1 ASSIGN . atribstat2 SEMICOLON statelist1
    (39) atribstat2 -> . expression
    (40) atribstat2 -> . allocexpression
    (41) atribstat2 -> . funccall
    (96) expression -> . numexpression expression1
    (93) allocexpression -> . NEW types LBRACKET numexpression RBRACKET allocexpression1
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 239
    IDENT           shift and go to state 234
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    LPAREN          shift and go to state 73

    atribstat2                     shift and go to state 300
    expression                     shift and go to state 236
    allocexpression                shift and go to state 237
    funccall                       shift and go to state 238
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 262

    (91) statelist1 -> IDENT LPAREN paramlistcall RPAREN . SEMICOLON statelist1

    SEMICOLON       shift and go to state 301


state 263

    (79) statelist1 -> FLOAT listdcl IDENT vardecl1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 302


state 264

    (80) statelist1 -> STRING listdcl IDENT vardecl1 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 303


state 265

    (82) statelist1 -> PRINT expression SEMICOLON statelist1 .

    RBRACE          reduce using rule 82 (statelist1 -> PRINT expression SEMICOLON statelist1 .)


state 266

    (83) statelist1 -> READ IDENT lvalue1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 304
    empty                          shift and go to state 104

state 267

    (84) statelist1 -> RETURN returnstat1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 84 (statelist1 -> RETURN returnstat1 SEMICOLON statelist1 .)


state 268

    (85) statelist1 -> IF LPAREN expression RPAREN . statement ifstat1 statelist1
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 305
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 269

    (86) statelist1 -> FOR LPAREN forstat1 SEMICOLON . forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (61) forstat2 -> . expression
    (62) forstat2 -> . empty
    (96) expression -> . numexpression expression1
    (127) empty -> .
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    SEMICOLON       reduce using rule 127 (empty -> .)
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    forstat2                       shift and go to state 306
    expression                     shift and go to state 249
    empty                          shift and go to state 250
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 270

    (87) statelist1 -> WHILE LPAREN expression RPAREN . statement statelist1
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 307
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 271

    (88) statelist1 -> LBRACE statelist RBRACE statelist1 .

    RBRACE          reduce using rule 88 (statelist1 -> LBRACE statelist RBRACE statelist1 .)


state 272

    (65) statelist -> FLOAT listdcl IDENT vardecl1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 308
    empty                          shift and go to state 104

state 273

    (66) statelist -> STRING listdcl IDENT vardecl1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 309
    empty                          shift and go to state 104

state 274

    (69) statelist -> READ IDENT lvalue1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 69 (statelist -> READ IDENT lvalue1 SEMICOLON statelist1 .)


state 275

    (71) statelist -> IF LPAREN expression RPAREN statement . ifstat1 statelist1
    (56) ifstat1 -> . ELSE statement
    (57) ifstat1 -> . empty
    (127) empty -> .

    ELSE            shift and go to state 288
    INT             reduce using rule 127 (empty -> .)
    FLOAT           reduce using rule 127 (empty -> .)
    STRING          reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    FOR             reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    LBRACE          reduce using rule 127 (empty -> .)
    BREAK           reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    RBRACE          reduce using rule 127 (empty -> .)

    ifstat1                        shift and go to state 310
    empty                          shift and go to state 289

state 276

    (72) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 . SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 311


state 277

    (73) statelist -> WHILE LPAREN expression RPAREN statement . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 312
    empty                          shift and go to state 104

state 278

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN . LBRACE statelist RBRACE funclist1

    LBRACE          shift and go to state 313


state 279

    (34) vardecl1 -> LBRACKET numexpression RBRACKET vardecl1 .

    SEMICOLON       reduce using rule 34 (vardecl1 -> LBRACKET numexpression RBRACKET vardecl1 .)


state 280

    (93) allocexpression -> NEW types . LBRACKET numexpression RBRACKET allocexpression1

    LBRACKET        shift and go to state 314


state 281

    (8) types -> INT .

    LBRACKET        reduce using rule 8 (types -> INT .)


state 282

    (9) types -> FLOAT .

    LBRACKET        reduce using rule 9 (types -> FLOAT .)


state 283

    (10) types -> STRING .

    LBRACKET        reduce using rule 10 (types -> STRING .)


state 284

    (37) atribstat1 -> LBRACKET numexpression RBRACKET atribstat1 .

    ASSIGN          reduce using rule 37 (atribstat1 -> LBRACKET numexpression RBRACKET atribstat1 .)


state 285

    (47) paramlistcall2 -> COMMA paramlistcall .

    RPAREN          reduce using rule 47 (paramlistcall2 -> COMMA paramlistcall .)


state 286

    (45) paramlistcall1 -> LBRACKET numexpression RBRACKET . paramlistcall1
    (45) paramlistcall1 -> . LBRACKET numexpression RBRACKET paramlistcall1
    (46) paramlistcall1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 189
    COMMA           reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    paramlistcall1                 shift and go to state 315
    empty                          shift and go to state 190

state 287

    (55) ifstat -> IF LPAREN expression RPAREN statement ifstat1 .

    $end            reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    ELSE            reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    INT             reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    FLOAT           reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    STRING          reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    IDENT           reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    PRINT           reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    READ            reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    RETURN          reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    IF              reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    FOR             reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    WHILE           reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    LBRACE          reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    BREAK           reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    SEMICOLON       reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)
    RBRACE          reduce using rule 55 (ifstat -> IF LPAREN expression RPAREN statement ifstat1 .)


state 288

    (56) ifstat1 -> ELSE . statement
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 316
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 289

    (57) ifstat1 -> empty .

    ELSE            reduce using rule 57 (ifstat1 -> empty .)
    $end            reduce using rule 57 (ifstat1 -> empty .)
    INT             reduce using rule 57 (ifstat1 -> empty .)
    FLOAT           reduce using rule 57 (ifstat1 -> empty .)
    STRING          reduce using rule 57 (ifstat1 -> empty .)
    IDENT           reduce using rule 57 (ifstat1 -> empty .)
    PRINT           reduce using rule 57 (ifstat1 -> empty .)
    READ            reduce using rule 57 (ifstat1 -> empty .)
    RETURN          reduce using rule 57 (ifstat1 -> empty .)
    IF              reduce using rule 57 (ifstat1 -> empty .)
    FOR             reduce using rule 57 (ifstat1 -> empty .)
    WHILE           reduce using rule 57 (ifstat1 -> empty .)
    LBRACE          reduce using rule 57 (ifstat1 -> empty .)
    BREAK           reduce using rule 57 (ifstat1 -> empty .)
    SEMICOLON       reduce using rule 57 (ifstat1 -> empty .)
    RBRACE          reduce using rule 57 (ifstat1 -> empty .)


state 290

    (58) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON . forstat1 RPAREN statement
    (59) forstat1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (60) forstat1 -> . empty
    (127) empty -> .

    IDENT           shift and go to state 151
    RPAREN          reduce using rule 127 (empty -> .)

    forstat1                       shift and go to state 317
    empty                          shift and go to state 152

state 291

    (59) forstat1 -> IDENT lvalue1 atribstat1 ASSIGN . atribstat2
    (39) atribstat2 -> . expression
    (40) atribstat2 -> . allocexpression
    (41) atribstat2 -> . funccall
    (96) expression -> . numexpression expression1
    (93) allocexpression -> . NEW types LBRACKET numexpression RBRACKET allocexpression1
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    NEW             shift and go to state 239
    IDENT           shift and go to state 234
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    LPAREN          shift and go to state 73

    atribstat2                     shift and go to state 318
    expression                     shift and go to state 236
    allocexpression                shift and go to state 237
    funccall                       shift and go to state 238
    numexpression                  shift and go to state 61
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 292

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE . statelist RBRACE
    (64) statelist -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (65) statelist -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (66) statelist -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (67) statelist -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (68) statelist -> . PRINT expression SEMICOLON statelist1
    (69) statelist -> . READ IDENT lvalue1 SEMICOLON statelist1
    (70) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (71) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (72) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (73) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (74) statelist -> . LBRACE statelist RBRACE statelist1
    (75) statelist -> . BREAK SEMICOLON statelist1
    (76) statelist -> . SEMICOLON statelist1
    (77) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 36
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 37
    PRINT           shift and go to state 41
    READ            shift and go to state 42
    RETURN          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    LBRACE          shift and go to state 34
    BREAK           shift and go to state 47
    SEMICOLON       shift and go to state 38

    statelist                      shift and go to state 319

state 293

    (11) paramlist -> STRING listdcl IDENT . paramlist1
    (15) paramlist1 -> . COMMA paramlist
    (16) paramlist1 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 321
    RPAREN          reduce using rule 127 (empty -> .)

    paramlist1                     shift and go to state 320
    empty                          shift and go to state 322

state 294

    (12) paramlist -> FLOAT listdcl IDENT . paramlist1
    (15) paramlist1 -> . COMMA paramlist
    (16) paramlist1 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 321
    RPAREN          reduce using rule 127 (empty -> .)

    paramlist1                     shift and go to state 323
    empty                          shift and go to state 322

state 295

    (13) paramlist -> INT listdcl IDENT . paramlist1
    (15) paramlist1 -> . COMMA paramlist
    (16) paramlist1 -> . empty
    (127) empty -> .

    COMMA           shift and go to state 321
    RPAREN          reduce using rule 127 (empty -> .)

    paramlist1                     shift and go to state 324
    empty                          shift and go to state 322

state 296

    (64) statelist -> INT listdcl IDENT vardecl1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 64 (statelist -> INT listdcl IDENT vardecl1 SEMICOLON statelist1 .)


state 297

    (67) statelist -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 325
    empty                          shift and go to state 104

state 298

    (77) statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .

    RBRACE          reduce using rule 77 (statelist -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .)


state 299

    (78) statelist1 -> INT listdcl IDENT vardecl1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 326
    empty                          shift and go to state 104

state 300

    (81) statelist1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 . SEMICOLON statelist1

    SEMICOLON       shift and go to state 327


state 301

    (91) statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 328
    empty                          shift and go to state 104

state 302

    (79) statelist1 -> FLOAT listdcl IDENT vardecl1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 329
    empty                          shift and go to state 104

state 303

    (80) statelist1 -> STRING listdcl IDENT vardecl1 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 330
    empty                          shift and go to state 104

state 304

    (83) statelist1 -> READ IDENT lvalue1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 83 (statelist1 -> READ IDENT lvalue1 SEMICOLON statelist1 .)


state 305

    (85) statelist1 -> IF LPAREN expression RPAREN statement . ifstat1 statelist1
    (56) ifstat1 -> . ELSE statement
    (57) ifstat1 -> . empty
    (127) empty -> .

    ELSE            shift and go to state 288
    INT             reduce using rule 127 (empty -> .)
    FLOAT           reduce using rule 127 (empty -> .)
    STRING          reduce using rule 127 (empty -> .)
    IDENT           reduce using rule 127 (empty -> .)
    PRINT           reduce using rule 127 (empty -> .)
    READ            reduce using rule 127 (empty -> .)
    RETURN          reduce using rule 127 (empty -> .)
    IF              reduce using rule 127 (empty -> .)
    FOR             reduce using rule 127 (empty -> .)
    WHILE           reduce using rule 127 (empty -> .)
    LBRACE          reduce using rule 127 (empty -> .)
    BREAK           reduce using rule 127 (empty -> .)
    SEMICOLON       reduce using rule 127 (empty -> .)
    RBRACE          reduce using rule 127 (empty -> .)

    ifstat1                        shift and go to state 331
    empty                          shift and go to state 289

state 306

    (86) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 . SEMICOLON forstat1 RPAREN statement statelist1

    SEMICOLON       shift and go to state 332


state 307

    (87) statelist1 -> WHILE LPAREN expression RPAREN statement . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 333
    empty                          shift and go to state 104

state 308

    (65) statelist -> FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 65 (statelist -> FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1 .)


state 309

    (66) statelist -> STRING listdcl IDENT vardecl1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 66 (statelist -> STRING listdcl IDENT vardecl1 SEMICOLON statelist1 .)


state 310

    (71) statelist -> IF LPAREN expression RPAREN statement ifstat1 . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 334
    empty                          shift and go to state 104

state 311

    (72) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON . forstat1 RPAREN statement statelist1
    (59) forstat1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (60) forstat1 -> . empty
    (127) empty -> .

    IDENT           shift and go to state 151
    RPAREN          reduce using rule 127 (empty -> .)

    forstat1                       shift and go to state 335
    empty                          shift and go to state 152

state 312

    (73) statelist -> WHILE LPAREN expression RPAREN statement statelist1 .

    RBRACE          reduce using rule 73 (statelist -> WHILE LPAREN expression RPAREN statement statelist1 .)


state 313

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE . statelist RBRACE funclist1
    (64) statelist -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (65) statelist -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (66) statelist -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (67) statelist -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (68) statelist -> . PRINT expression SEMICOLON statelist1
    (69) statelist -> . READ IDENT lvalue1 SEMICOLON statelist1
    (70) statelist -> . RETURN returnstat1 SEMICOLON statelist1
    (71) statelist -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (72) statelist -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (73) statelist -> . WHILE LPAREN expression RPAREN statement statelist1
    (74) statelist -> . LBRACE statelist RBRACE statelist1
    (75) statelist -> . BREAK SEMICOLON statelist1
    (76) statelist -> . SEMICOLON statelist1
    (77) statelist -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1

    INT             shift and go to state 36
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    IDENT           shift and go to state 37
    PRINT           shift and go to state 41
    READ            shift and go to state 42
    RETURN          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46
    LBRACE          shift and go to state 34
    BREAK           shift and go to state 47
    SEMICOLON       shift and go to state 38

    statelist                      shift and go to state 336

state 314

    (93) allocexpression -> NEW types LBRACKET . numexpression RBRACKET allocexpression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 337
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 315

    (45) paramlistcall1 -> LBRACKET numexpression RBRACKET paramlistcall1 .

    COMMA           reduce using rule 45 (paramlistcall1 -> LBRACKET numexpression RBRACKET paramlistcall1 .)
    RPAREN          reduce using rule 45 (paramlistcall1 -> LBRACKET numexpression RBRACKET paramlistcall1 .)


state 316

    (56) ifstat1 -> ELSE statement .

    ELSE            reduce using rule 56 (ifstat1 -> ELSE statement .)
    $end            reduce using rule 56 (ifstat1 -> ELSE statement .)
    INT             reduce using rule 56 (ifstat1 -> ELSE statement .)
    FLOAT           reduce using rule 56 (ifstat1 -> ELSE statement .)
    STRING          reduce using rule 56 (ifstat1 -> ELSE statement .)
    IDENT           reduce using rule 56 (ifstat1 -> ELSE statement .)
    PRINT           reduce using rule 56 (ifstat1 -> ELSE statement .)
    READ            reduce using rule 56 (ifstat1 -> ELSE statement .)
    RETURN          reduce using rule 56 (ifstat1 -> ELSE statement .)
    IF              reduce using rule 56 (ifstat1 -> ELSE statement .)
    FOR             reduce using rule 56 (ifstat1 -> ELSE statement .)
    WHILE           reduce using rule 56 (ifstat1 -> ELSE statement .)
    LBRACE          reduce using rule 56 (ifstat1 -> ELSE statement .)
    BREAK           reduce using rule 56 (ifstat1 -> ELSE statement .)
    SEMICOLON       reduce using rule 56 (ifstat1 -> ELSE statement .)
    RBRACE          reduce using rule 56 (ifstat1 -> ELSE statement .)


state 317

    (58) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 . RPAREN statement

    RPAREN          shift and go to state 338


state 318

    (59) forstat1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 .

    SEMICOLON       reduce using rule 59 (forstat1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 .)
    RPAREN          reduce using rule 59 (forstat1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 .)


state 319

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist . RBRACE

    RBRACE          shift and go to state 339


state 320

    (11) paramlist -> STRING listdcl IDENT paramlist1 .

    RPAREN          reduce using rule 11 (paramlist -> STRING listdcl IDENT paramlist1 .)


state 321

    (15) paramlist1 -> COMMA . paramlist
    (11) paramlist -> . STRING listdcl IDENT paramlist1
    (12) paramlist -> . FLOAT listdcl IDENT paramlist1
    (13) paramlist -> . INT listdcl IDENT paramlist1
    (14) paramlist -> . empty
    (127) empty -> .

    STRING          shift and go to state 202
    FLOAT           shift and go to state 203
    INT             shift and go to state 204
    RPAREN          reduce using rule 127 (empty -> .)

    paramlist                      shift and go to state 340
    empty                          shift and go to state 205

state 322

    (16) paramlist1 -> empty .

    RPAREN          reduce using rule 16 (paramlist1 -> empty .)


state 323

    (12) paramlist -> FLOAT listdcl IDENT paramlist1 .

    RPAREN          reduce using rule 12 (paramlist -> FLOAT listdcl IDENT paramlist1 .)


state 324

    (13) paramlist -> INT listdcl IDENT paramlist1 .

    RPAREN          reduce using rule 13 (paramlist -> INT listdcl IDENT paramlist1 .)


state 325

    (67) statelist -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1 .

    RBRACE          reduce using rule 67 (statelist -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1 .)


state 326

    (78) statelist1 -> INT listdcl IDENT vardecl1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 78 (statelist1 -> INT listdcl IDENT vardecl1 SEMICOLON statelist1 .)


state 327

    (81) statelist1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 341
    empty                          shift and go to state 104

state 328

    (91) statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .

    RBRACE          reduce using rule 91 (statelist1 -> IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1 .)


state 329

    (79) statelist1 -> FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 79 (statelist1 -> FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1 .)


state 330

    (80) statelist1 -> STRING listdcl IDENT vardecl1 SEMICOLON statelist1 .

    RBRACE          reduce using rule 80 (statelist1 -> STRING listdcl IDENT vardecl1 SEMICOLON statelist1 .)


state 331

    (85) statelist1 -> IF LPAREN expression RPAREN statement ifstat1 . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 342
    empty                          shift and go to state 104

state 332

    (86) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON . forstat1 RPAREN statement statelist1
    (59) forstat1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (60) forstat1 -> . empty
    (127) empty -> .

    IDENT           shift and go to state 151
    RPAREN          reduce using rule 127 (empty -> .)

    forstat1                       shift and go to state 343
    empty                          shift and go to state 152

state 333

    (87) statelist1 -> WHILE LPAREN expression RPAREN statement statelist1 .

    RBRACE          reduce using rule 87 (statelist1 -> WHILE LPAREN expression RPAREN statement statelist1 .)


state 334

    (71) statelist -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .

    RBRACE          reduce using rule 71 (statelist -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .)


state 335

    (72) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 . RPAREN statement statelist1

    RPAREN          shift and go to state 344


state 336

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist . RBRACE funclist1

    RBRACE          shift and go to state 345


state 337

    (93) allocexpression -> NEW types LBRACKET numexpression . RBRACKET allocexpression1

    RBRACKET        shift and go to state 346


state 338

    (58) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN . statement
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 347
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 339

    (7) funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE .

    DEF             reduce using rule 7 (funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE .)
    $end            reduce using rule 7 (funcdef -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE .)


state 340

    (15) paramlist1 -> COMMA paramlist .

    RPAREN          reduce using rule 15 (paramlist1 -> COMMA paramlist .)


state 341

    (81) statelist1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1 .

    RBRACE          reduce using rule 81 (statelist1 -> IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1 .)


state 342

    (85) statelist1 -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .

    RBRACE          reduce using rule 85 (statelist1 -> IF LPAREN expression RPAREN statement ifstat1 statelist1 .)


state 343

    (86) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 . RPAREN statement statelist1

    RPAREN          shift and go to state 348


state 344

    (72) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN . statement statelist1
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 349
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 345

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE . funclist1
    (5) funclist1 -> . DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1
    (6) funclist1 -> . empty
    (127) empty -> .

    DEF             shift and go to state 51
    $end            reduce using rule 127 (empty -> .)

    funclist1                      shift and go to state 350
    empty                          shift and go to state 52

state 346

    (93) allocexpression -> NEW types LBRACKET numexpression RBRACKET . allocexpression1
    (94) allocexpression1 -> . LBRACKET numexpression RBRACKET allocexpression1
    (95) allocexpression1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 351
    SEMICOLON       reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    allocexpression1               shift and go to state 352
    empty                          shift and go to state 353

state 347

    (58) forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .

    $end            reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    ELSE            reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    INT             reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    FLOAT           reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    STRING          reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    IDENT           reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    PRINT           reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    READ            reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    RETURN          reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    IF              reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    FOR             reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    WHILE           reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    LBRACE          reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    BREAK           reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    SEMICOLON       reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)
    RBRACE          reduce using rule 58 (forstat -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement .)


state 348

    (86) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN . statement statelist1
    (19) statement -> . vardecl SEMICOLON
    (20) statement -> . atribstat SEMICOLON
    (21) statement -> . printstat SEMICOLON
    (22) statement -> . readstat SEMICOLON
    (23) statement -> . returnstat SEMICOLON
    (24) statement -> . ifstat
    (25) statement -> . forstat
    (26) statement -> . whilestat
    (27) statement -> . LBRACE statelist RBRACE
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . SEMICOLON
    (30) statement -> . funccall SEMICOLON
    (31) vardecl -> . INT IDENT vardecl1
    (32) vardecl -> . FLOAT IDENT vardecl1
    (33) vardecl -> . STRING IDENT vardecl1
    (36) atribstat -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2
    (49) printstat -> . PRINT expression
    (50) readstat -> . READ expression
    (51) returnstat -> . RETURN returnstat1
    (55) ifstat -> . IF LPAREN expression RPAREN statement ifstat1
    (58) forstat -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement
    (63) whilestat -> . WHILE LPAREN expression RPAREN statement
    (42) funccall -> . IDENT LPAREN paramlistcall RPAREN

    LBRACE          shift and go to state 14
    BREAK           shift and go to state 15
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    IDENT           shift and go to state 19
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 27

    statement                      shift and go to state 354
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    whilestat                      shift and go to state 13
    funccall                       shift and go to state 16

state 349

    (72) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 355
    empty                          shift and go to state 104

state 350

    (5) funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1 .

    $end            reduce using rule 5 (funclist1 -> DEF IDENT LPAREN paramlist RPAREN LBRACE statelist RBRACE funclist1 .)


state 351

    (94) allocexpression1 -> LBRACKET . numexpression RBRACKET allocexpression1
    (105) numexpression -> . term numexpression1
    (111) term -> . unaryexpr term1
    (117) unaryexpr -> . addsub factor
    (118) unaryexpr -> . factor
    (109) addsub -> . PLUS
    (110) addsub -> . MINUS
    (119) factor -> . int_constant
    (120) factor -> . float_constant
    (121) factor -> . string_constant
    (122) factor -> . null_constant
    (123) factor -> . IDENT lvalue1
    (124) factor -> . LPAREN numexpression RPAREN

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    int_constant    shift and go to state 68
    float_constant  shift and go to state 69
    string_constant shift and go to state 70
    null_constant   shift and go to state 71
    IDENT           shift and go to state 72
    LPAREN          shift and go to state 73

    numexpression                  shift and go to state 356
    term                           shift and go to state 62
    unaryexpr                      shift and go to state 63
    addsub                         shift and go to state 64
    factor                         shift and go to state 65

state 352

    (93) allocexpression -> NEW types LBRACKET numexpression RBRACKET allocexpression1 .

    SEMICOLON       reduce using rule 93 (allocexpression -> NEW types LBRACKET numexpression RBRACKET allocexpression1 .)
    RPAREN          reduce using rule 93 (allocexpression -> NEW types LBRACKET numexpression RBRACKET allocexpression1 .)


state 353

    (95) allocexpression1 -> empty .

    SEMICOLON       reduce using rule 95 (allocexpression1 -> empty .)
    RPAREN          reduce using rule 95 (allocexpression1 -> empty .)


state 354

    (86) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement . statelist1
    (78) statelist1 -> . INT listdcl IDENT vardecl1 SEMICOLON statelist1
    (79) statelist1 -> . FLOAT listdcl IDENT vardecl1 SEMICOLON statelist1
    (80) statelist1 -> . STRING listdcl IDENT vardecl1 SEMICOLON statelist1
    (81) statelist1 -> . IDENT lvalue1 atribstat1 ASSIGN atribstat2 SEMICOLON statelist1
    (82) statelist1 -> . PRINT expression SEMICOLON statelist1
    (83) statelist1 -> . READ IDENT lvalue1 SEMICOLON statelist1
    (84) statelist1 -> . RETURN returnstat1 SEMICOLON statelist1
    (85) statelist1 -> . IF LPAREN expression RPAREN statement ifstat1 statelist1
    (86) statelist1 -> . FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1
    (87) statelist1 -> . WHILE LPAREN expression RPAREN statement statelist1
    (88) statelist1 -> . LBRACE statelist RBRACE statelist1
    (89) statelist1 -> . BREAK SEMICOLON statelist1
    (90) statelist1 -> . SEMICOLON statelist1
    (91) statelist1 -> . IDENT LPAREN paramlistcall RPAREN SEMICOLON statelist1
    (92) statelist1 -> . empty
    (127) empty -> .

    INT             shift and go to state 92
    FLOAT           shift and go to state 94
    STRING          shift and go to state 95
    IDENT           shift and go to state 93
    PRINT           shift and go to state 96
    READ            shift and go to state 97
    RETURN          shift and go to state 98
    IF              shift and go to state 99
    FOR             shift and go to state 100
    WHILE           shift and go to state 101
    LBRACE          shift and go to state 102
    BREAK           shift and go to state 103
    SEMICOLON       shift and go to state 90
    RBRACE          reduce using rule 127 (empty -> .)

    statelist1                     shift and go to state 357
    empty                          shift and go to state 104

state 355

    (72) statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .

    RBRACE          reduce using rule 72 (statelist -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .)


state 356

    (94) allocexpression1 -> LBRACKET numexpression . RBRACKET allocexpression1

    RBRACKET        shift and go to state 358


state 357

    (86) statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .

    RBRACE          reduce using rule 86 (statelist1 -> FOR LPAREN forstat1 SEMICOLON forstat2 SEMICOLON forstat1 RPAREN statement statelist1 .)


state 358

    (94) allocexpression1 -> LBRACKET numexpression RBRACKET . allocexpression1
    (94) allocexpression1 -> . LBRACKET numexpression RBRACKET allocexpression1
    (95) allocexpression1 -> . empty
    (127) empty -> .

    LBRACKET        shift and go to state 351
    SEMICOLON       reduce using rule 127 (empty -> .)
    RPAREN          reduce using rule 127 (empty -> .)

    allocexpression1               shift and go to state 359
    empty                          shift and go to state 353

state 359

    (94) allocexpression1 -> LBRACKET numexpression RBRACKET allocexpression1 .

    SEMICOLON       reduce using rule 94 (allocexpression1 -> LBRACKET numexpression RBRACKET allocexpression1 .)
    RPAREN          reduce using rule 94 (allocexpression1 -> LBRACKET numexpression RBRACKET allocexpression1 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 19 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 37 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 72 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 93 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 151 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 191 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 234 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 247 resolved as shift
WARNING: reduce/reduce conflict in state 76 resolved using rule (returnstat1 -> IDENT)
WARNING: rejected rule (empty -> <empty>) in state 76
WARNING: reduce/reduce conflict in state 194 resolved using rule (unaryexpr -> addsub factor)
WARNING: rejected rule (unaryexpr -> factor) in state 194
